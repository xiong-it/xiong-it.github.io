<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MichaelX&#39;s Blog</title>
  
  <subtitle>MichaelX的开发博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.michaelx.tech/"/>
  <updated>2022-12-06T12:13:54.242Z</updated>
  <id>http://blog.michaelx.tech/</id>
  
  <author>
    <name>MichaelX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Design Patterns in Android：装饰模式</title>
    <link href="http://blog.michaelx.tech/2018-06/Design-Patterns-in-Android%EF%BC%9A%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2018-06/Design-Patterns-in-Android：装饰模式/</id>
    <published>2018-06-13T09:12:00.000Z</published>
    <updated>2022-12-06T12:13:54.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言"><a href="#装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言" class="headerlink" title="装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言"></a>装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。<br><span id="more"></span><br>前言</h1><p>装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。</p><pre><code>本文原创作者MichaelX。 CSDN博客：https://blog.csdn.net/xiong_it 掘金主页：https://juejin.im/user/56efe6461ea493005565dafd 知乎专栏：https://zhuanlan.zhihu.com/c_144117654 个人博客：http://blog.michaelx.tech </code></pre><p>转载请注明出处。</p><h1 id="装饰模式定义"><a href="#装饰模式定义" class="headerlink" title="装饰模式定义"></a>装饰模式定义</h1><blockquote><p>装饰者模式：也叫wrapper模式。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式相比生成子类更加灵活，提供了有别于继承的另一种选择。</p></blockquote><h1 id="装饰模式的UML类图"><a href="#装饰模式的UML类图" class="headerlink" title="装饰模式的UML类图"></a>装饰模式的UML类图</h1><p><img src="http://oler3nq5z.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fuml.png-80style" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fuml.png-80style" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>有四个角色需要说明：</p><ul><li>Component抽象构件<br>Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。</li></ul><p><strong>注意：</strong>在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。</p><ul><li><p>ConcreteComponent 具体构件<br>ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。</p></li><li><p>Decorator装饰角色<br>一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。</p></li><li><p>具体装饰角色<br>ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。</p></li></ul><h1 id="装饰模式示例代码"><a href="#装饰模式示例代码" class="headerlink" title="装饰模式示例代码"></a>装饰模式示例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">     <span class="comment">//抽象的方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">     <span class="comment">//具体实现</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;do Something&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="literal">null</span>;        </span><br><span class="line">     <span class="comment">//通过构造函数传递被修饰者</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component _component)</span>&#123;</span><br><span class="line">             <span class="built_in">this</span>.component = _component;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//委托给被修饰者执行</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="built_in">this</span>.component.operate();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">     <span class="comment">//定义被修饰者</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ConcreteDecorator1</span><span class="params">(Component _component)</span>&#123;</span><br><span class="line">             <span class="built_in">super</span>(_component);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;method1 修饰&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//重写父类的Operation方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">             <span class="built_in">this</span>.method1();</span><br><span class="line">             <span class="built_in">super</span>.operate();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator2</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">     <span class="comment">//定义被修饰者</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">ConcreteDecorator2</span><span class="params">(Component _component)</span>&#123;</span><br><span class="line">             <span class="built_in">super</span>(_component);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//定义自己的修饰方法</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;method2修饰&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//重写父类的Operation方法</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operate</span><span class="params">()</span>&#123;</span><br><span class="line">             <span class="built_in">super</span>.operate();</span><br><span class="line">             <span class="built_in">this</span>.method2();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">             <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">             <span class="comment">//第一次修饰</span></span><br><span class="line">             component = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator1</span>(component);</span><br><span class="line">             <span class="comment">//第二次修饰</span></span><br><span class="line">             component = <span class="keyword">new</span> <span class="title class_">ConcreteDecorator2</span>(component);</span><br><span class="line">             <span class="comment">//修饰后运行</span></span><br><span class="line">             component.operate();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Android源码中的装饰模式"><a href="#Android源码中的装饰模式" class="headerlink" title="Android源码中的装饰模式"></a>Android源码中的装饰模式</h1><h2 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h2><p>Context是Android中一个几乎无处不在的角色，ContextWrapper&#x2F;ContextThemeWrapper就在继承过程中承担了ContextImpl的装饰者角色。<br><img src="http://oler3nq5z.bkt.clouddn.com/Context%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fuml%E7%B1%BB%E5%9B%BE.png-80style" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/Context%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8Fuml%E7%B1%BB%E5%9B%BE.png-80style" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>ContextThemeWrapper部分代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextThemeWrapper</span> <span class="keyword">extends</span> <span class="title class_">ContextWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mThemeResource;</span><br><span class="line">    <span class="keyword">private</span> Resources.Theme mTheme;</span><br><span class="line">    <span class="keyword">private</span> LayoutInflater mInflater;</span><br><span class="line">    <span class="keyword">private</span> Configuration mOverrideConfiguration;</span><br><span class="line">    <span class="keyword">private</span> Resources mResources;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AssetManager <span class="title function_">getAssets</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Ensure we&#x27;re returning assets with the correct configuration.</span></span><br><span class="line">        <span class="keyword">return</span> getResourcesInternal().getAssets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resources <span class="title function_">getResources</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getResourcesInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Resources <span class="title function_">getResourcesInternal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mResources == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOverrideConfiguration == <span class="literal">null</span>) &#123;</span><br><span class="line">                mResources = <span class="built_in">super</span>.getResources();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Context</span> <span class="variable">resContext</span> <span class="operator">=</span> createConfigurationContext(mOverrideConfiguration);</span><br><span class="line">                mResources = resContext.getResources();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resources.Theme <span class="title function_">getTheme</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTheme != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mTheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mThemeResource = Resources.selectDefaultTheme(mThemeResource,</span><br><span class="line">                getApplicationInfo().targetSdkVersion);</span><br><span class="line">        initializeTheme();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mTheme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSystemService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LAYOUT_INFLATER_SERVICE.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInflater == <span class="literal">null</span>) &#123;</span><br><span class="line">                mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mInflater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBaseContext().getSystemService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onApplyThemeResource</span><span class="params">(Resources.Theme theme, <span class="type">int</span> resId, <span class="type">boolean</span> first)</span> &#123;</span><br><span class="line">        theme.applyStyle(resId, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initializeTheme</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> mTheme == <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            mTheme = getResources().newTheme();</span><br><span class="line">            <span class="keyword">final</span> Resources.<span class="type">Theme</span> <span class="variable">theme</span> <span class="operator">=</span> getBaseContext().getTheme();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="literal">null</span>) &#123;</span><br><span class="line">                mTheme.setTo(theme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onApplyThemeResource(mTheme, mThemeResource, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h2><p>还有一个比较典型的例子是RecyclerView通过RecyclerView.ItemDecorator来扩展样式。<br>不过这个是一个变种的装饰者，这个实践比较另类的地方在于：我们通常是在装饰者的的执行方法中扩展被代理对象的行为，而RecyclerView+ItemDecorator的实践则恰恰相反，ItemDecorator反倒成了被代理对象，RecyclerView成了装饰者。</p><h1 id="Android开发中的装饰模式实践"><a href="#Android开发中的装饰模式实践" class="headerlink" title="Android开发中的装饰模式实践"></a>Android开发中的装饰模式实践</h1><p>说实话，笔者自己也没有实践过装饰模式，但是有一个场景需求应该是可以应用装饰模式的。比如一个直播场景，点击礼物时需要礼物飞出来，双击有一个爱心❤️飘出来，那么礼物和爱心就可以看成是直播画面的装饰者，类关系如下：<br><img src="http://oler3nq5z.bkt.clouddn.com/%E7%9B%B4%E6%92%AD%E8%A3%85%E9%A5%B0%E8%80%85uml.jpg-80style" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E7%9B%B4%E6%92%AD%E8%A3%85%E9%A5%B0%E8%80%85uml.jpg-80style" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>GirlView：主播画面<br>GirlDecorator：主播画面装饰者<br>GiftView：礼物效果<br>LoveView：爱心效果</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>特点：</strong>装饰模式其实就是在代理某个对象过程中，给特定的代理行为前后加上不同的装饰行为，比如文中的<code>ContextThemeWrapper</code>就在代理<code>ContextImpl</code>的<code>getSystemService</code>这个行为过程中，加上了返回LayoutInflater这个装饰行为。因此，我们也可以认为<strong>装饰模式其实是一种特殊的代理模式</strong></p><p>装饰模式的优缺点<br>优点：</p><ul><li><p>装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。</p></li><li><p>装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。</p></li><li><p>装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。</p></li></ul><p>缺点：</p><ul><li>装饰太多层时会增加系统复杂度，有时出现问题可能无法快速定位。</li></ul><p>当某个对象的行为需要加强，并且可能有多种加强的需求时，那么装饰模式有可能就能排上用场了。</p><p>好了，今天的《设计模式Android篇：装饰模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》（设计模式Android篇）</a>系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言&quot;&gt;&lt;a href=&quot;#装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言&quot; class=&quot;headerlink&quot; title=&quot;装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言&quot;&gt;&lt;/a&gt;装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="装饰模式" scheme="http://blog.michaelx.tech/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Decorator" scheme="http://blog.michaelx.tech/tags/Decorator/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：责任链模式</title>
    <link href="http://blog.michaelx.tech/2018-05/Design-Patterns-in-Android%EF%BC%9A%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2018-05/Design-Patterns-in-Android：责任链模式/</id>
    <published>2018-05-14T09:55:55.000Z</published>
    <updated>2022-12-06T12:13:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家分享的是《设计模式Android篇:责任链模式》。<br>今天将通过Android源码和Android开发案例跟大家讲解什么是责任链模式。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>非常抱歉，本系列博客长达半年没更新了，今日偶得灵感，更新一波《设计模式Android篇:责任链模式》。点击此处查看<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》</a>系列其他文章。</p><blockquote><p>本文原创作者MichaelX。<br>CSDN博客：<a href="http://blog.csdn.net/xiong_it">http://blog.csdn.net/xiong_it</a><br>掘金主页：<a href="https://juejin.im/user/56efe6461ea493005565dafd">https://juejin.im/user/56efe6461ea493005565dafd</a><br>知乎专栏：<a href="https://zhuanlan.zhihu.com/c_144117654">https://zhuanlan.zhihu.com/c_144117654</a><br>个人博客：<a href="http://blog.michaelx.tech/">http://blog.michaelx.tech</a><br>转载请注明出处。</p></blockquote><h2 id="责任链模式定义"><a href="#责任链模式定义" class="headerlink" title="责任链模式定义"></a>责任链模式定义</h2><blockquote><p>职责链(Chain-of-responsibility pattern):它是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p></blockquote><h2 id="责任链模式的UML类图"><a href="#责任链模式的UML类图" class="headerlink" title="责任链模式的UML类图"></a>责任链模式的UML类图</h2><p><img src="http://oler3nq5z.bkt.clouddn.com/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png-80style" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png-80style" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="责任链模式类图"><br><strong>责任链模式各角色分工：</strong></p><ul><li>Client:发出请求的高层代码。</li><li>Handler:定义一个处理请求的接口。一般会定义一个处理请求的抽象方法（handleRequest()），以及一个set方法(setSuccessor)来指定下后续处理者。</li><li>ConcreteHandler:具体的请求处理者，收到请求后可以自己处理，也可以将请求传递给后续处理者。</li></ul><h2 id="责任链示例代码"><a href="#责任链示例代码" class="headerlink" title="责任链示例代码"></a>责任链示例代码</h2><p>这里举个栗子：<strong>老王</strong>在中介所要买个<strong>二手房</strong>，他提出价格过高，希望得到更多的优惠，比如88折，中介经纪人小明收到请求。以下是处理流程。</p><p>Client发起购房请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">HouseBuyer</span> <span class="variable">laowang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseBuyer</span>(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">laowang.buyHouse(<span class="string">&quot;88折卖不卖？&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseBuyer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyHouse</span><span class="params">(<span class="type">int</span> accountOff)</span> &#123;</span><br><span class="line"><span class="type">AbsAgency</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Staff</span>(<span class="string">&quot;底层员工小明&quot;</span>);</span><br><span class="line">xiaoming.handle(accountOff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象处理者Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbsAgency</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> AbsAgency mAgency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(AbsAgency agency)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.mAgency = agency;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理折扣</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> accountOff)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> AbsAgency <span class="title function_">geNextHandler</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mAgency;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体处理者：处理购房请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Staff</span> <span class="keyword">extends</span> <span class="title class_">AbsAgency</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> accountOff)</span> &#123;</span><br><span class="line"><span class="comment">// 如果折扣低于80折，不出售；</span></span><br><span class="line"><span class="comment">// 如果90折以上，一线员工自行处理;</span></span><br><span class="line"><span class="comment">// 低于90折，需要汇报经理处理</span></span><br><span class="line"><span class="keyword">if</span> (accountOff &lt;= <span class="number">80</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;价格太低，要吃土咯。。。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (accountOff &gt; <span class="number">90</span> &amp;&amp; accountOff &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;价格合适，卖给你了。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">setNextHandler(<span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;上级经理&quot;</span>));</span><br><span class="line">getNextHandler().handle(accountOff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">AbsAgency</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="type">int</span> accountOff)</span> &#123;</span><br><span class="line"><span class="comment">// 如果折扣低于80折，不出售；</span></span><br><span class="line"><span class="comment">// 根据人品决定是否接受购房请求</span></span><br><span class="line"><span class="keyword">if</span> (accountOff &lt;= <span class="number">80</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;价格太低，要吃土咯。。。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老王人品还行，成交。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终老王的购房请求在经理这个级别得到了处理，但是老王才不关心谁解决的，只要能低价买到这个房子就行了。</p><h2 id="Android源码中责任链模式"><a href="#Android源码中责任链模式" class="headerlink" title="Android源码中责任链模式"></a>Android源码中责任链模式</h2><p>责任链模式思想在Android源码中的体现莫过于：触摸事件的处理和分发了。每当用户接触屏幕时，Android都会将其打包成一个MotionEvent对象从ViewTree自顶而下的分发处理。<br>代码过多，这里只用一张图表示其思路：<br><img src="http://oler3nq5z.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%B1%82%E7%BA%A7.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%B1%82%E7%BA%A7.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"><br>其方向为：<code>Activity---&gt;ViewGroup---&gt;View</code><br>具体源码可参考郭神的<a href="https://blog.csdn.net/guolin_blog/article/details/9097463">《Android事件分发机制完全解析，带你从源码的角度彻底理解(上)》</a>，阅读源码，我们可以发现dispatchTouchEvent有点类似上面责任链实例代码中的handle()方法，自己能处理就处理，处理不了就向下一级分发处理。</p><h2 id="Android开发中的责任链模式实践"><a href="#Android开发中的责任链模式实践" class="headerlink" title="Android开发中的责任链模式实践"></a>Android开发中的责任链模式实践</h2><p>举个例子，我们的图片需要设计三级缓存，那么它是怎么取缓存的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbsCacheManager</span> <span class="variable">bmpCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemoryCache</span>();</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> bmpCache.getCache(cacheKey);</span><br></pre></td></tr></table></figure><p>先定义一个缓存抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbsCacheManager &#123;</span><br><span class="line">protected AbsCacheManager mCache;</span><br><span class="line">    // 获取Bitmap</span><br><span class="line">public abstract Bitmap getCache(String cacheKey); </span><br><span class="line"></span><br><span class="line">public void setNextHandler(AbsCacheManager manager) &#123;</span><br><span class="line">mCache = manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public AbsCacheManager getNextHandler() &#123;</span><br><span class="line">return mCache;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是具体实施者：内存缓存，磁盘缓存，网络获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryCache</span> <span class="keyword">extends</span> <span class="title class_">AbsCacheManager</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">getCache</span><span class="params">(String cacheKey)</span> &#123;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> getCacheFromMemory(cacheKey);</span><br><span class="line"><span class="comment">// 如果内存缓存为空，则将请求传递给下一位：磁盘缓存来处理</span></span><br><span class="line"><span class="keyword">if</span> (bmp == <span class="literal">null</span>) &#123;</span><br><span class="line">setNextHandler(<span class="keyword">new</span> <span class="title class_">DiskCache</span>());</span><br><span class="line">bmp = getNextHandler().getCache(cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiskCache</span> <span class="keyword">extends</span> <span class="title class_">AbsCacheManager</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">getCache</span><span class="params">(String cacheKey)</span> &#123;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> getCacheFromDisk(cacheKey);</span><br><span class="line"><span class="comment">// 如果磁盘缓存为空，则将请求传递给下一位：网络图片下载来处理</span></span><br><span class="line"><span class="keyword">if</span> (bmp == <span class="literal">null</span>) &#123;</span><br><span class="line">setNextHandler(<span class="keyword">new</span> <span class="title class_">NetworkFetchManager</span>());</span><br><span class="line">bmp = getNextHandler().getCache(cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetworkFetchManager</span> <span class="keyword">extends</span> <span class="title class_">AbsCacheManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Bitmap <span class="title function_">getCache</span><span class="params">(String cacheKey)</span> &#123;</span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bmp</span> <span class="operator">=</span> getCacheFromNetWork(cacheKey);</span><br><span class="line"><span class="keyword">return</span> bmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一条责任链跃然纸上：内存—&gt;磁盘-&gt;网络。</p><p>当然，以上没有考虑线程切换问题，实际操作是需要考虑耗时操作在子线程执行的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实责任链模式就是在某种场景下：有一个请求需要处理，但是最终处理者又不确定的时候采用的一种模式。<br>但是其处理者对于客户端是透明的，无需知道谁将处理这个请求，只需要抛出请求，拿到结果即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家分享的是《设计模式Android篇:责任链模式》。&lt;br&gt;今天将通过Android源码和Android开发案例跟大家讲解什么是责任链模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="责任链模式" scheme="http://blog.michaelx.tech/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Chain-of-responsibility" scheme="http://blog.michaelx.tech/tags/Chain-of-responsibility/"/>
    
  </entry>
  
  <entry>
    <title>Android笔记：Bitmap.Config与内存占用的关系</title>
    <link href="http://blog.michaelx.tech/2017-12/Android%E7%AC%94%E8%AE%B0%EF%BC%9ABitmap.Config%E4%B8%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%9A%84%E5%85%B3/"/>
    <id>http://blog.michaelx.tech/2017-12/Android笔记：Bitmap.Config与内存占用的关/</id>
    <published>2017-12-04T11:12:18.000Z</published>
    <updated>2022-12-06T12:13:54.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bitmap内存占用与Config关系笔记关于内存占用"><a href="#Bitmap内存占用与Config关系笔记关于内存占用" class="headerlink" title="Bitmap内存占用与Config关系笔记关于内存占用"></a>Bitmap内存占用与Config关系笔记<br><span id="more"></span><br>关于内存占用</h1><p>Q:请问Bitmap的内存占用如何计算？<br>A:int momery &#x3D; higthPixel * widthPixel * config因子;</p><p>什么是config因子？接着看。</p><h1 id="Config因子"><a href="#Config因子" class="headerlink" title="Config因子"></a>Config因子</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Bitmap.Config &#123;</span><br><span class="line">    ALPHA_8,</span><br><span class="line">    RGB_565,</span><br><span class="line">    RGB_444, // 3.0及以上已废弃，使用RGB_8888代替</span><br><span class="line">    ARGB_8888</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ALPHA_8（<strong>基本不用</strong>）:每个像素使用一个独立的alpha通道存储，该通道占用8bit，即：每个像素占用<code>1byte = 8bit / 8</code>内存，如果bitmap使用这种config编码，以上config因子为1；注意：此属性会导致RGB通道信息丢失，只剩下透明度，所以基本不会用到</li><li>RGB_565:只编码RGB通道信息，没有透明alpha通道信息，Red红色通道信息占用5位内存，Green绿色通道信息占用6位内存，Blue蓝色通道信息占用5位内存。每个像素占用<code>2 byte= (5bit + 6bit + 5bit) / 8</code> 内存，支持2^16 &#x3D; 65535种颜色。质量较好，此时config因子为2；</li><li>ARGB_8888:每个通道（Alpha+RGB）都各占用8位内存，支持2^32 &#x3D; 1600w种颜色，质量最好，每个像素占用<code>4 byte = 8bit * 4 / 8</code>内存，此时config因子为4。</li></ul><p>RGB_565比ARGB_8888节省内存相信很多同学都知道，但是为什么RGB_565更节省内存？Bitmap每个像素的内存占用是怎么来的？<br>希望本文能解决一些同学的疑惑。因为RGB_565牺牲了alpha通道，不支持透明度，并且RGB每个通道信息较ARGB_888更少。</p><h1 id="不同Config加载效果图"><a href="#不同Config加载效果图" class="headerlink" title="不同Config加载效果图"></a>不同Config加载效果图</h1><p><img src="http://oler3nq5z.bkt.clouddn.com/bmpconfig.png-halfstyle" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/bmpconfig.png-halfstyle" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="demo示例图"></p><div style="background: #A0C8FB; width: 300px; height: 100px; margin: 0 auto;">原颜色值：#9966AAFF</div><hr><div style="background: #616161; width: 300px; height: 100px; margin: 0 auto;">使用ALPHA_8加载丢失了RGB信息</div><hr><div style="background: #39659C; width: 300px; height: 100px; margin: 0 auto;">使用RGB_565加载丢失了alpha通道透明度</div><hr><div style="background: #A0C8FB; width: 300px; height: 100px; margin: 0 auto;">使用ARGB_8888可正常加载</div><br><blockquote><p>本文作者MichaelX，个人博客：<a href="http://blog.michaelx.tech/">http://blog.michaelx.tech</a> 本文遵从<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC协议</a>，转载请注明出处。</p></blockquote><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当加载一张1080 * 1920px的图片时，使用以上config加载的内存占用情况分别为：</p><ul><li>ALPHA_8（<strong>基本不用</strong>）:1080 * 1920 byte &#x3D; 2025Kb &#x3D; 2Mb</li><li>RGB_565:1080 * 1920 * 2 byte &#x3D; 4050Kb &#x3D; 4Mb</li><li>ARGB_8888:1080 * 1920 * 4 byte &#x3D; 8100Kb &#x3D; 8Mb</li></ul><p>可以酌情选择合适的config进行加载，但是最好全局只使用一个config，否则易导致个别图片信息丢失或者加载错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bitmap内存占用与Config关系笔记关于内存占用&quot;&gt;&lt;a href=&quot;#Bitmap内存占用与Config关系笔记关于内存占用&quot; class=&quot;headerlink&quot; title=&quot;Bitmap内存占用与Config关系笔记关于内存占用&quot;&gt;&lt;/a&gt;Bitmap内存占用与Config关系笔记&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="Bitmap.Config" scheme="http://blog.michaelx.tech/tags/Bitmap-Config/"/>
    
  </entry>
  
  <entry>
    <title>Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程</title>
    <link href="http://blog.michaelx.tech/2017-11/Hexo%E9%81%87%E4%B8%8ATravis-CI%EF%BC%9A%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.michaelx.tech/2017-11/Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程/</id>
    <published>2017-11-30T06:10:18.000Z</published>
    <updated>2022-12-06T12:13:54.242Z</updated>
    
    <content type="html"><![CDATA[<p>今天笔者就来介绍下利用<a href="https://travis-ci.org/">travis-ci</a>这个持续集成平台简化发布流程.</p><span id="more"></span><p>相信很多同学都有自己的博客，如果没有，可以参看<a href="http://blog.csdn.net/xiong_it/article/details/55193816">《Hexo建站：部署到github》</a>，利用Hexo和github pages服务搭建一个美观便捷的博客，Hexo可以将你编写的md文档解析渲染成html网页，最后通过git推送到github即可形成一个网站。</p><h1 id="Hexo发布博客流程"><a href="#Hexo发布博客流程" class="headerlink" title="Hexo发布博客流程"></a>Hexo发布博客流程</h1><ol><li>搭建hexo环境（一系列软件安装，配置）</li><li>hexo new post “文章名称”</li><li>编写md文档</li><li>hexo clean</li><li>hexo generate</li><li>hexo deploy</li></ol><p>以上第一步一般只在第一次搭建的时候需要进行，后续只要执行2~6步即可。但是存在一些情况，假如你需要在不同的电脑上发布博客呢？假如你重装了系统呢？是不是需要重新来一次？要知道最繁琐的步骤就是第一步，这里面可以分出很多步来做，看过上面那篇博客或者自己正在使用<code>hexo+gh</code>手动发布博客的同学都知道多痛苦。</p><p>今天笔者就来介绍下利用<a href="https://travis-ci.org/">travis-ci</a>这个持续集成平台简化发布流程，简化后流程:</p><ol><li>编写md文档</li><li>git push</li></ol><p>利用travis大大提高了效率！是不是很诱人？</p><h1 id="Travis-CI简介"><a href="#Travis-CI简介" class="headerlink" title="Travis-CI简介"></a>Travis-CI简介</h1><p>Travis CI 是开源持续集成构建项目，用来构建托管在GitHub上的代码。它提供了多种编程语言的支持，包括JavaScript，Java，Scala，Ruby，PHP，Haskell和Erlang在内的多种语言。</p><p>当我们每次进行<code>git push</code>等动作时，Travis CI 会自动检测我们的提交，然后根据配置文件<code>.travis.yml</code>帮我们自动生成、部署静态网页。</p><h1 id="事先预备"><a href="#事先预备" class="headerlink" title="事先预备"></a>事先预备</h1><h2 id="推送hexo博客源码到github"><a href="#推送hexo博客源码到github" class="headerlink" title="推送hexo博客源码到github"></a>推送hexo博客源码到github</h2><ol><li>cd进入自己的本地hexo博客文件夹，就是你要发布博客时进入的那个文件夹。</li><li>将自己本地所有hexo博客源码文件push到github。<br>推送教程：<a href="http://blog.csdn.net/xiong_it/article/details/68944728">《如何提交代码到Github》</a></li></ol><blockquote><p>注意：不是<code>hexo deploy</code>更新博客repo！而是直接把本地博客托管到github。</p></blockquote><p>笔者直接把本地hexo博客源码托管到了<a href="http://xiong-it.github.io/">xiong-it.github.io</a>的<strong>hexo</strong>分支，博客网站则在默认的<strong>master</strong>分支上。不想采取分支管理的话，你也可以把本地hexo博客托管到独立仓库，但是在配置travis同步时会有所不同。本文采取分支管理方式。</p><h2 id="配置github-token"><a href="#配置github-token" class="headerlink" title="配置github token"></a>配置github token</h2><p>那既然需要使用travis自动化更新你的博客，travis自然需要读写你的github上的repo。github提供了token机制来供外部访问你的仓库。</p><p>进入<a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a>，生成一个供travis读写你的github用的token，至于token的权限，笔者直接全选了，但是不建议这样做，风险比较大，token注意保密，待会会用到。<br><img src="http://oler3nq5z.bkt.clouddn.com/github_token.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/github_token.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"></p><h1 id="配置Travis-CI"><a href="#配置Travis-CI" class="headerlink" title="配置Travis-CI"></a>配置Travis-CI</h1><p>使用github账号登陆<a href="https://travis-ci.org/">travis</a>，如果没有github账号的同学，可以参考<a href="http://blog.csdn.net/xiong_it/article/details/68944728">《如何提交代码到Github》</a>注册一个自己的github账号。</p><h2 id="在travis进入仓库同步管理"><a href="#在travis进入仓库同步管理" class="headerlink" title="在travis进入仓库同步管理"></a>在travis进入仓库同步管理</h2><p>进入<a href="https://travis-ci.org/profile/">https://travis-ci.org/profile</a>，<strong>打开刚才托管的hexo博客源码仓库同步开关，不一定是博客网站repo</strong>。由于笔者直接把本地hexo博客源码托管到了<a href="http://xiong-it.github.io/">xiong-it.github.io</a>的<strong>hexo</strong>分支，所以也就是打开网站repo。如果你不是采取的分支管理，而是将hexo博客源码托管道独立repo，打开对应的github repo开关即可。<br>如图：<br><img src="http://oler3nq5z.bkt.clouddn.com/travis_sync.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/travis_sync.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"></p><h2 id="travis设置"><a href="#travis设置" class="headerlink" title="travis设置"></a>travis设置</h2><p>点击上图中红色圆圈，进入设置页，设置自动化编译时机，自动化编译过程中需要用到的变量。<br> <img src="http://oler3nq5z.bkt.clouddn.com/travis_setting1.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/travis_setting1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"></p><p> <img src="http://oler3nq5z.bkt.clouddn.com/travis_setting2.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/travis_setting2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"></p><p>以上设置的含义是：</p><ul><li>只在.travis.yml文件存在时编译，必选！</li><li>当仓库&#x2F;分支发生更新时编译，也就是push后进行编译的意思，一般会需要选择，方便自动化构建。</li><li>加了GH_TOEKN等变量，value值为刚才预备工作中准备的token字符串</li></ul><h2 id="编写-travis-yml文件"><a href="#编写-travis-yml文件" class="headerlink" title="编写.travis.yml文件"></a>编写.travis.yml文件</h2><p><code>.travis.yml</code>是<a href="https://travis-ci.org/">travis</a>平台进行自动化构建的配置文件，travis会根据配置文件生成一个shell自动化脚本。</p><p>进入hexo博客源码本地repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">touch .travis.yml</span><br><span class="line">vim .travis.yml</span><br></pre></td></tr></table></figure><p>.travis.yml示例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定语言环境</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 指定需要sudo权限</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="string">required</span></span><br><span class="line"><span class="comment"># 指定node_js版本</span></span><br><span class="line"><span class="attr">node_js:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="number">7.9</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 指定缓存模块，可选。缓存可加快编译速度。</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 指定博客源码分支，因人而异。hexo博客源码托管在独立repo则不用设置此项</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hexo</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start: Build Lifecycle</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-deployer-git</span> <span class="string">--save</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 执行清缓存，生成网页操作</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;yourName&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;yourEmail&quot;</span></span><br><span class="line">  <span class="comment"># 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line"><span class="comment"># End: Build LifeCycle</span></span><br></pre></td></tr></table></figure><p>修改下_config.yml文件的deploy节点：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:xiong-it/xiong-it.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改后</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># 下方的gh_token会被.travis.yml中sed命令替换</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gh_token@github.com/xiong-it/xiong-it.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/xiong-it/xiong-it.github.io/tree/hexo">yml示例传送门</a></p><p>最后将两个yml文件push更新到hexo博客源码branch或者独立repo，就会在<a href="https://travis-ci.org/ttp://oler3nq5z.bkt.clouddn.com/travis_setting2.png">travis后台</a>成功看到第一次构建了。</p><blockquote><p>欢迎访问我的个人hexo博客：<a href="http://xiong-it.github.io/">http://xiong-it.github.io</a></p></blockquote><h1 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h1><p>以后每次更新博客，只需要编写md文件，放入hexo&#x2F;source&#x2F;_post&#x2F;文件夹下，<code>git add，commit，push</code>后，push操作也可以直接使用刚才申请的token，而无需在不同电脑上配置ssh共密钥。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push https://&lt;your_token&gt;@github.com/xiong-it/xiong-it.github.io.git hexo:hexo</span><br></pre></td></tr></table></figure><p>travis就会读取hexo博客源码分支下的<code>.travis.yml</code>文件，自动帮我们生成并部署网站了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天笔者就来介绍下利用&lt;a href=&quot;https://travis-ci.org/&quot;&gt;travis-ci&lt;/a&gt;这个持续集成平台简化发布流程.&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://blog.michaelx.tech/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="http://blog.michaelx.tech/tags/Hexo/"/>
    
      <category term="travis" scheme="http://blog.michaelx.tech/tags/travis/"/>
    
  </entry>
  
  <entry>
    <title>Android：使用LoadingLayout来展示加载数据时不同状态</title>
    <link href="http://blog.michaelx.tech/2017-11/Android%EF%BC%9A%E4%BD%BF%E7%94%A8LoadingLayout%E6%9D%A5%E5%B1%95%E7%A4%BA%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%97%B6%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.michaelx.tech/2017-11/Android：使用LoadingLayout来展示加载数据时不同状态/</id>
    <published>2017-11-21T05:11:00.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LoadingLayout-应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介"><a href="#LoadingLayout-应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介" class="headerlink" title="LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介"></a>LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。<br><span id="more"></span><br>LoadingLayout简介</h1><p><a href="https://www.apache.org/licenses/LICENSE-2.0"><img src="https://img.shields.io/badge/license-Apache%202-green.svg" class="lazyload" data-srcset="https://img.shields.io/badge/license-Apache%202-green.svg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="License"></a><br><a href="https://bintray.com/xiong-it/AndroidRepo/LoadingLayout/_latestVersion"> <img src="https://api.bintray.com/packages/xiong-it/AndroidRepo/LoadingLayout/images/download.svg" class="lazyload" data-srcset="https://api.bintray.com/packages/xiong-it/AndroidRepo/LoadingLayout/images/download.svg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Download"> </a><br>应用于Android中的一个加载数据不同状态的类库（自定义控件）。 <a href="https://github.com/xiong-it/LoadingLayout">https://github.com/xiong-it/LoadingLayout</a> </p><h1 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h1><h1 id="打开你的app-module中的build-gradle-添加依赖：Sample"><a href="#打开你的app-module中的build-gradle-添加依赖：Sample" class="headerlink" title="打开你的app module中的build.gradle,添加依赖：Sample  "></a>打开你的app module中的build.gradle,添加依赖：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&#x27;tech.michaelx.loadinglibrary:loadinglibrary:1.0.1&#x27;</span></span><br></pre></td></tr></table></figure><br><br>Sample  </h1><p>在layout的xml中使用如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tech.michaelx.loadinglibrary.LoadingLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/loading_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:contentDescription</span>=<span class="string">&quot;loadingBackground可以是drawable或者颜色&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:emptyView</span>=<span class="string">&quot;@layout/empty_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:errorView</span>=<span class="string">&quot;@layout/failure_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:loadingAnimator</span>=<span class="string">&quot;@animator/loading&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:loadingBackground</span>=<span class="string">&quot;#1296db&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:loadingView</span>=<span class="string">&quot;@layout/loading_layout&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:retryLoadAlways</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:showLoadingDebug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;本页面使用属性自定义loading各种状态&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tech.michaelx.loadinglibrary.LoadingLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用自定义属性</strong>  </p><p><code>app:loadingView=&quot;@layout/loading_layout&quot;</code> :指定加载时的展示布局，可以为空，为空时使用系统默认ProgressBar<br><code>app:loadingAnimator=&quot;@animator/loading&quot;</code>:只用上述属性制定时，该属性方可生效，作用于加载布局的动画<br><code>app:loadingBackground=&quot;#1296db&quot;</code>:指定加载过程中页面背景，可以是颜色或者drawable，默认为adnroid:color&#x2F;white<br><code>app:emptyView=&quot;@layout/empty_layout&quot;</code>:指定了数据为空时的展示布局，可以为空，有默认布局，详细可看下方演示gif图<br><code>app:errorView=&quot;@layout/failure_layout&quot;</code>:指定加载失败时的展示布局，可以为空，有默认布局，详细可看下方演示gif图<br><code>app:retryLoadAlways=&quot;true&quot;</code>:是否开启数据为空时点击重试，默认为false<br><code>app:showLoadingDebug=&quot;true&quot;</code>:是否开启布局预览调试，默认为false，开启后可以在AS中正常预览布局文件，<strong>打包时请一定写false！</strong><br><br><br>其他更多属性请看  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;LoadingLayout&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置数据为空的layout--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;emptyView&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载失败的layout--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;errorView&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载中的layout--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;loadingView&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载动画id--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;loadingAnimator&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载中的背景，或者颜色--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;loadingBackground&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference|color&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置默认Progressbar的progress_drawable--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;loadingProgressDrawable&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置数据为空时的图片--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;emptyDrawable&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置数据为空时的提示语--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;emptyText&quot;</span> <span class="attr">format</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载失败时的图片--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;errorDrawable&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置加载失败时的提示语--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;errorText&quot;</span> <span class="attr">format</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置是否总是点击重试，无论数据为空或者失败，默认false--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;retryLoadAlways&quot;</span> <span class="attr">format</span>=<span class="string">&quot;boolean&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置自动显示加载调试--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;showLoadingDebug&quot;</span> <span class="attr">format</span>=<span class="string">&quot;boolean&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>Activity&#x2F;Fragment代码中  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化布局对象  </span></span><br><span class="line">mLoadingLayout = (LoadingLayout) findViewById(R.id.loading_layout);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 加载完毕/加载成功  </span></span><br><span class="line">mLoadingLayout.loadComplete();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 数据为空  </span></span><br><span class="line">mLoadingLayout.showEmpty();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 加载失败  </span></span><br><span class="line">mLoadingLayout.loadFailure();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 设置点击重试监听  </span></span><br><span class="line">mLoadingLayout.setOnRetryLoadListener(OnRetryLoadListener);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示加载中  </span></span><br><span class="line"><span class="comment">// 代码调用了setLoadingView()，才需要手动调用showLoading()</span></span><br><span class="line">mLoadingLayout.showLoading();</span><br></pre></td></tr></table></figure><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><h1 id="加载中，加载完成，数据为空，加载失败，点击重试-几种状态演示gif注意事项"><a href="#加载中，加载完成，数据为空，加载失败，点击重试-几种状态演示gif注意事项" class="headerlink" title="加载中，加载完成，数据为空，加载失败，点击重试 几种状态演示gif注意事项  "></a>加载中，加载完成，数据为空，加载失败，点击重试 几种状态演示gif<br><img src="https://raw.githubusercontent.com/xiong-it/LoadingLayout/master/output/LoadingLayout.gif" class="lazyload" data-srcset="https://raw.githubusercontent.com/xiong-it/LoadingLayout/master/output/LoadingLayout.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="加载几种状态演示"><br><br>注意事项  </h1><p>LoadingLayout需要依赖于<code>appcompat-v7</code> &amp;<code>support-annotations</code>，请在工程中添加这两个依赖（版本可自定义，不建议低于25.3.1）：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.android.support:appcompat-v7:25.3.1&quot;  </span><br><span class="line">compile &#x27;com.android.support:support-annotations:25.3.1&#x27;  </span><br></pre></td></tr></table></figure><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p>感谢阅读，欢迎体验：<a href="https://github.com/xiong-it/LoadingLayout">https://github.com/xiong-it/LoadingLayout</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LoadingLayout-应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介&quot;&gt;&lt;a href=&quot;#LoadingLayout-应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介&quot; class=&quot;headerlink&quot; title=&quot;LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介&quot;&gt;&lt;/a&gt;LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="开源" scheme="http://blog.michaelx.tech/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="LoadingLayout" scheme="http://blog.michaelx.tech/tags/LoadingLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android开发：RecyclerView平滑流畅的滑动到指定位置</title>
    <link href="http://blog.michaelx.tech/2017-10/Android%E5%BC%80%E5%8F%91%EF%BC%9ARecyclerView%E5%B9%B3%E6%BB%91%E6%B5%81%E7%95%85%E7%9A%84%E6%BB%91%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/"/>
    <id>http://blog.michaelx.tech/2017-10/Android开发：RecyclerView平滑流畅的滑动到指定位置/</id>
    <published>2017-10-17T12:11:00.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RecyclerView-smoothScrollToPosition-int-滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景"><a href="#RecyclerView-smoothScrollToPosition-int-滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景" class="headerlink" title="RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景"></a>RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。<br><span id="more"></span><br>背景</h1><p>在项目中，想使RecyclerView慢慢的平缓滑动指定位置，于是使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView.smoothScrollToPosition(int);</span><br></pre></td></tr></table></figure><p>发现效果并不理想，滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth（流畅的，平滑的），也就是说smoothScrollToPosition没有滑动效果，黑人问号？？？</p><pre><code>本文原创作者MichaelX，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。</code></pre><h1 id="探索历程"><a href="#探索历程" class="headerlink" title="探索历程"></a>探索历程</h1><p>既然函数名是流畅平缓的滑动到指定位置，为什么并不理想呢？查看源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void smoothScrollToPosition(int position) &#123;</span><br><span class="line">       // ···省略无关代码，mLayout是该RecyclerView的LayoutManager对象</span><br><span class="line">       mLayout.smoothScrollToPosition(this, mState, position);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以实际上是调用<code>RecyclerView.LayoutManager.smoothScrollToPosition()</code>方法，这是个抽象方法。由于笔者项目中是<code>LinearLayoutManager</code>于是找到其具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">       public void smoothScrollToPosition(RecyclerView recyclerView,</span><br><span class="line">                                          RecyclerView.State state, final int position) &#123;</span><br><span class="line"></span><br><span class="line">           LinearSmoothScroller smoothScroller = new LinearSmoothScroller(context);</span><br><span class="line"></span><br><span class="line">           smoothScroller.setTargetPosition(position);</span><br><span class="line">           startSmoothScroll(smoothScroller);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>生成一个<code>RecyclerView.SmoothScroller</code>的子类<code>LinearSmoothScroller</code>对象smoothScroller，接着利用smoothScroller去完成剩下的滑动工作。</p><p>于是进去LinearSmoothScroller看看。<strong>重大发现</strong>—里面有一个跟滑动速度相关的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calculates the scroll speed.</span><br><span class="line"> * 计算滑动速度</span><br><span class="line"> * 返回：滑过1px所需的时间消耗。</span><br><span class="line"> */</span><br><span class="line">protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;</span><br><span class="line">    // MILLISECONDS_PER_INCH是常量，等于20f</span><br><span class="line">    return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然<code>RecyclerView.smoothScrollToPosition(int);</code>很快，是不是延长其滑动时间就可以呢？</p><h1 id="解决smoothScrollToPosition无效"><a href="#解决smoothScrollToPosition无效" class="headerlink" title="解决smoothScrollToPosition无效"></a>解决smoothScrollToPosition无效</h1><p>为了验证上节延长滑动时间的想法，自定义一个LinearLayoutManager:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SmoothScrollLayoutManager extends LinearLayoutManager &#123;</span><br><span class="line"></span><br><span class="line">        public SmoothScrollLayoutManager(Context context) &#123;</span><br><span class="line">            super(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void smoothScrollToPosition(RecyclerView recyclerView,</span><br><span class="line">                                           RecyclerView.State state, final int position) &#123;</span><br><span class="line"></span><br><span class="line">            LinearSmoothScroller smoothScroller =</span><br><span class="line">                    new LinearSmoothScroller(recyclerView.getContext()) &#123;</span><br><span class="line">                        // 返回：滑过1px时经历的时间(ms)。</span><br><span class="line">                        @Override</span><br><span class="line">                        protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123;</span><br><span class="line">                            return 150f / displayMetrics.densityDpi;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">            smoothScroller.setTargetPosition(position);</span><br><span class="line">            startSmoothScroll(smoothScroller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Binggo！成功！调用<code>RecyclerView.smoothScrollToPosition(int);</code>发现滑动速度变慢很多，不再突兀，不再突然滑过去，没有任何过渡，而是缓慢滑过去，终于名副其实的<strong>smooth</strong>。</p><pre><code>本文原创作者MichaelX，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过自定义LinearLayoutManager，重写smoothScrollToPosition()方法中<code>LinearSmoothScroller</code>对象的<code>calculateSpeedPerPixel(DisplayMetrics)</code>方法,可以使<code>RecyclerView.smoothScrollToPosition(int);</code>平滑的流畅的滑动到指定位置。其他LayoutManager暂时没用到，需要读者自己尝试。</p><p>如果读者朋友们有其他的办法，欢迎留言交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RecyclerView-smoothScrollToPosition-int-滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景&quot;&gt;&lt;a href=&quot;#RecyclerView-smoothScrollToPosition-int-滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景&quot; class=&quot;headerlink&quot; title=&quot;RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景&quot;&gt;&lt;/a&gt;RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://blog.michaelx.tech/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>Android开发小记：编译ijkplayer以支持更多视频格式</title>
    <link href="http://blog.michaelx.tech/2017-09/%20Android%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%EF%BC%9A%E7%BC%96%E8%AF%91ijkplayer%E4%BB%A5%E6%94%AF%E6%8C%81%E6%9B%B4%E5%A4%9A%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-09/ Android开发小记：编译ijkplayer以支持更多视频格式/</id>
    <published>2017-09-22T13:11:02.000Z</published>
    <updated>2022-12-02T03:10:42.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg-x2F-mpg等更多格式视频。前言"><a href="#ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg-x2F-mpg等更多格式视频。前言" class="headerlink" title="ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。前言"></a>ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。<br><span id="more"></span><br>前言</h1><p>ijkplayer大法好，感谢B站大佬。ijkplayer基于FFmpeg开发，适配Android&#x2F;iOS平台。FFmpeg在开发界简直是神一般存在的项目，全平台全格式音视频编解码支持。像前段时间“杀程序员祭天”的暴风，受众颇广的QQ影音都是FFmpeg的受益者，因为不遵循GNU LGPL协议，也是FFmpeg项目耻辱柱上的成员。<br>但是ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。</p><h1 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h1><p>生产环境是MacOS或者Linux系统，笔者是MacOS，Android 6.0，这里以Mac为例记下自己编译ijkplayer for Android的过程。<code>build ijkplayer for Android.</code></p><h1 id="编译准备"><a href="#编译准备" class="headerlink" title="编译准备"></a>编译准备</h1><ol><li>安装homebrew：<code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li><li>安装git：<code>brew install git</code></li><li>安装yasm：<code>brew install yasm</code></li></ol><p>下载ijkplayer项目：<br><code>git clone https://github.com/Bilibili/ijkplayer.git</code></p><p>替换支持格式编译脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ijkplayer/config</span><br><span class="line">rm module.sh # 这是一个软链接，默认指向module-lite.sh</span><br><span class="line">ln -s module-default.sh module.sh</span><br></pre></td></tr></table></figure><p>设置编译环境变量：<br>在终端执行以下命令（<strong>具体请指向自己的路径</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_NDK=/Users/michaelx/Library/Android/sdk/ndk-bundle</span><br><span class="line">export ANDROID_SDK=/Users/michaelx/Library/Android/sdk</span><br></pre></td></tr></table></figure><p>官方建议NDK版本为r10e，笔者为r13.1，MacOS 10.12.6 ，实测通过编译。</p><h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>cd进入项目根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bash init-android.sh</span><br><span class="line">cd android/contrib</span><br><span class="line"># 执行以下两条命令</span><br><span class="line">./compile-ffmpeg.sh clean</span><br><span class="line"># 如果默认shell不是bash，建议执行以下命令</span><br><span class="line">bash compile-ffmpeg.sh clean</span><br><span class="line"></span><br><span class="line">./compile-ffmpeg.sh all</span><br><span class="line"># 如果默认shell不是bash，建议执行以下命令</span><br><span class="line">bash compile-ffmpeg.sh all</span><br></pre></td></tr></table></figure><p>执行过程中出现的以下类似提示可忽略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WARNING: aarch64-linux-android-pkg-config not found, library detection may fail.</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">[*] compile ffmpeg</span><br><span class="line">--------------------</span><br><span class="line">libavfilter/avfiltergraph.c: In function &#x27;avfilter_graph_free&#x27;:</span><br><span class="line">libavfilter/avfiltergraph.c:132:5: warning: &#x27;resample_lavr_opts&#x27; is deprecated (declared at libavfilter/avfilter.h:847) [-Wdeprecated-declarations]</span><br><span class="line">     av_freep(&amp;(*graph)-&gt;resample_lavr_opts);</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure><p>出现以下提示时FFmpeg编译完了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">[*] Finished</span><br><span class="line">--------------------</span><br><span class="line"># to continue to build ijkplayer, run script below,</span><br><span class="line">sh compile-ijk.sh</span><br></pre></td></tr></table></figure><p>那我们就可以编译ijkplayer拿到so动态库文件。按照提示执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash compile-ijk.sh</span><br><span class="line"># or</span><br><span class="line">sh compile-ijk.sh</span><br></pre></td></tr></table></figure><p>出现以下提示表示ijkplayer编译完毕:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= BPMDetect.cpp</span><br><span class="line">[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= PeakFinder.cpp</span><br><span class="line">[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= SoundTouch.cpp</span><br><span class="line">[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= mmx_optimized.cpp</span><br><span class="line">[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= ijksoundtouch_wrap.cpp</span><br><span class="line">[armeabi-v7a] Install        : libijkffmpeg.so =&gt; libs/armeabi-v7a/libijkffmpeg.so</span><br><span class="line">[armeabi-v7a] StaticLibrary  : libcpufeatures.a</span><br><span class="line">[armeabi-v7a] StaticLibrary  : libijkj4a.a</span><br><span class="line">[armeabi-v7a] StaticLibrary  : libandroid-ndk-profiler.a</span><br><span class="line">[armeabi-v7a] StaticLibrary  : libijksoundtouch.a</span><br><span class="line">[armeabi-v7a] StaticLibrary  : libyuv_static.a</span><br><span class="line">[armeabi-v7a] SharedLibrary  : libijksdl.so</span><br><span class="line">[armeabi-v7a] SharedLibrary  : libijkplayer.so</span><br><span class="line">[armeabi-v7a] Install        : libijksdl.so =&gt; libs/armeabi-v7a/libijksdl.so</span><br><span class="line">[armeabi-v7a] Install        : libijkplayer.so =&gt; libs/armeabi-v7a/libijkplayer.so</span><br><span class="line">/Users/michealx/Documents/ijkplayer/android</span><br></pre></td></tr></table></figure><p>进入<code>ijkplayer/android/ijkplayer/armeabi-v7a/</code> 就可以拿到编出来的ijkplayer so了，那么编出来的ijkplayer so怎么用到项目当中呢？接着看。</p><h1 id="使用编译的ijkplayer-so库"><a href="#使用编译的ijkplayer-so库" class="headerlink" title="使用编译的ijkplayer so库"></a>使用编译的ijkplayer so库</h1><p>ijkplayer的默认用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;tv.danmaku.ijk.media:ijkplayer-java:0.8.3&#x27;</span><br><span class="line">compile &#x27;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.3&#x27;</span><br></pre></td></tr></table></figure><p>第二个依赖没有任何代码，实际只是so库，既然要使用自己编译出来的so，那么第二个依赖可以去掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &#x27;tv.danmaku.ijk.media:ijkplayer-java:0.8.3&#x27;</span><br><span class="line">// compile &#x27;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.3&#x27;</span><br></pre></td></tr></table></figure><p>将自己编译出来的3个so文件放入项目的<code>main/jniLibs/armeabi-v7a/</code>下即可。播放代码无需做任何改变，现在ijkplayer就可以播放avi，mpeg&#x2F;mpg多更多格式视频了。</p><p>至于ijkplayer更多玩法，笔者也还在探索，如果后续有空笔者会陆续更新。</p><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><p>基于ijkplayer 0.8.3编译的Android so库（比默认依赖支持更多格式）:<br>github:<a href="https://github.com/xiong-it/compiled_ijkplayer4android">compiled_ijkplayer4android</a>(后续会根据ijkplayer版本持续更新)</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p><a href="https://github.com/Bilibili/ijkplayer">Bilibili&#x2F;ijkplayer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg-x2F-mpg等更多格式视频。前言&quot;&gt;&lt;a href=&quot;#ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg-x2F-mpg等更多格式视频。前言&quot; class=&quot;headerlink&quot; title=&quot;ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&amp;#x2F;mpg等更多格式视频。前言&quot;&gt;&lt;/a&gt;ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&amp;#x2F;mpg等更多格式视频。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="ijkplayer" scheme="http://blog.michaelx.tech/tags/ijkplayer/"/>
    
  </entry>
  
  <entry>
    <title>Android开发：使用AutoInputAuthCode快速实现自动填写验证码</title>
    <link href="http://blog.michaelx.tech/2017-05/Android%E5%BC%80%E5%8F%91%EF%BC%9A%E4%BD%BF%E7%94%A8AutoInputAuthCode%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://blog.michaelx.tech/2017-05/Android开发：使用AutoInputAuthCode快速实现自动填写验证码/</id>
    <published>2017-05-09T09:36:18.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用AutoInputAuthCode快速实现自动填写验证码前言"><a href="#使用AutoInputAuthCode快速实现自动填写验证码前言" class="headerlink" title="使用AutoInputAuthCode快速实现自动填写验证码前言"></a>使用AutoInputAuthCode快速实现自动填写验证码<br><span id="more"></span><br>前言</h1><p>该类库的实现原理:<a href="http://blog.csdn.net/xiong_it/article/details/50997084">《Android开发:实现APP自动填写注册验证码功能》</a>。感兴趣的可以看下。  </p><p>项目地址：<a href="https://github.com/xiong-it/AutoInputAuthCode">https://github.com/xiong-it/AutoInputAuthCode</a></p><blockquote><p>本文原创作者:<a href="http://blog.csdn.net/xiong_it">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E6%9D%A5%E6%BA%90">http://blog.csdn.net/xiong_it.转载请注明来源</a></p></blockquote><hr><h1 id="AutoInputAuthCode使用介绍"><a href="#AutoInputAuthCode使用介绍" class="headerlink" title="AutoInputAuthCode使用介绍"></a>AutoInputAuthCode使用介绍</h1><p>在Android Studio打开你的app module中的build.gradle,添加依赖：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">compile</span> <span class="string">&#x27;tech.michaelx.authcode:authcode:1.0.0&#x27;</span> <span class="comment">// 添加依赖</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果无法下载上述依赖，可以打开你的项目根目录下的build.gradle，添加maven仓库地址</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">&#x27;https://dl.bintray.com/xiong-it/AndroidRepo&#x27;</span>&#125; <span class="comment">// 添加这行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="示范代码"><a href="#示范代码" class="headerlink" title="示范代码"></a>示范代码</h1><p>AutoInputAuthCode是一个帮助Android开发者快速实现自动填写验证码的类库，客户端示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CodeConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeConfig</span>.Builder()</span><br><span class="line">                        .codeLength(<span class="number">4</span>) <span class="comment">// 设置验证码长度</span></span><br><span class="line">                        .smsFromStart(<span class="number">133</span>) <span class="comment">// 设置验证码发送号码前几位数字</span></span><br><span class="line">                        <span class="comment">//.smsFrom(1690123456789) // 如果验证码发送号码固定，则可以设置验证码发送完整号码</span></span><br><span class="line">                        .smsBodyStartWith(<span class="string">&quot;百度科技&quot;</span>) <span class="comment">// 设置验证码短信开头文字</span></span><br><span class="line">                        .smsBodyContains(<span class="string">&quot;验证码&quot;</span>) <span class="comment">// 设置验证码短信内容包含文字</span></span><br><span class="line">                        .build();</span><br><span class="line">                        </span><br><span class="line">AuthCode.getInstance().with(context).config(config).into(EditText);</span><br></pre></td></tr></table></figure><ol><li>通过单例获取一个AuthCode对象;</li><li>提供一个上下文对象给AuthCode，放心，我会妥善处理你的上下文;</li><li>提供一个你的验证码特征描述;</li><li>告诉AuthCode你想将验证码写入哪个EditText.</li></ol><p>搞定，收工！  </p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="http://oler3nq5z.bkt.clouddn.com/authcode2.gif" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/authcode2.gif" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>自动填写验证码需要读取短信权限，请在清单中添加权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_SMS&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_SMS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>由于读取短信在API 23（Android 6.0）上权限级别是<strong>dangerous</strong>。所以还需要动态申请权限，但是申请权限需要依赖于Activity或者Fragment中的onRequestPermissionsResult()回调，所以需要开发者自己实现。  </p><p>可参考<a href="https://github.com/xiong-it/AutoInputAuthCode">AutoInputAuthCode</a>中sample的代码。</p><p>该库实现原理请参考：<a href="http://blog.csdn.net/xiong_it/article/details/50997084">《Android开发:实现APP自动填写注册验证码功能》</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该库实际上被完成有一段时间了，一直在试着上传jcenter，有空把上传代码到jcenter总结下发出来，虽然上传jcenter在网上教程挺多的，但是很多都不够细节，容易误解，我就是被坑的一个。  </p><p>祝大家撸码愉快！<br>项目地址：<a href="https://github.com/xiong-it/AutoInputAuthCode">https://github.com/xiong-it/AutoInputAuthCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用AutoInputAuthCode快速实现自动填写验证码前言&quot;&gt;&lt;a href=&quot;#使用AutoInputAuthCode快速实现自动填写验证码前言&quot; class=&quot;headerlink&quot; title=&quot;使用AutoInputAuthCode快速实现自动填写验证码前言&quot;&gt;&lt;/a&gt;使用AutoInputAuthCode快速实现自动填写验证码&lt;br&gt;
    
    </summary>
    
      <category term="开源" scheme="http://blog.michaelx.tech/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="AutoInputAuthCode" scheme="http://blog.michaelx.tech/tags/AutoInputAuthCode/"/>
    
      <category term="验证码" scheme="http://blog.michaelx.tech/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>科学上网:安装Shadowsocks Server on VPS</title>
    <link href="http://blog.michaelx.tech/2017-05/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%AE%89%E8%A3%85Shadowsocks-Server-on-VPS/"/>
    <id>http://blog.michaelx.tech/2017-05/科学上网-安装Shadowsocks-Server-on-VPS/</id>
    <published>2017-05-03T08:46:37.000Z</published>
    <updated>2022-12-02T03:10:42.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作为一名开发者，科学上网是一个很强的诉求，至今被-墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言"><a href="#作为一名开发者，科学上网是一个很强的诉求，至今被-墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言" class="headerlink" title="作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言"></a>作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外<br><span id="more"></span><br>前言</h1><p>作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外。科学上网的方法大致如下几种：</p><ol><li>修改本机hosts，可访问的网站有限</li><li>vpn：容易被封</li><li>shadowsocks-俗称：影梭</li><li>etc…</li></ol><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>其中修改hosts的方法成本最低，也最简单，网上找到需要访问网站的ip，写进本机hosts文件中即可。这样访问被|墙网站时，机器先访问hosts文件，发现已经有ip了，就不会访问dns服务器去要求解析域名了，而是直接根据指定ip去访问被|墙网站。  </p><p>vpn的方式由于其容易被探测的缘故，容易被封。  </p><p>根据socks5代理方式实现的shadowsocks项目，由于其隐蔽性存活至今。其需要一外国的服务器上装shadowsocks服务端实现流量中转，然后本地机器装shadowsocks客户端进行科学上网。当然网上也有很多的shadowsocks账号购买，服务器它给你搭好了，然后就售卖账号，但是也存在些骗子收完钱跑路的，拿着账号上不了网，当然也存在奸商超售账号的情况，许多人买完账号挤在一个服务器上爬蜗牛。那么为什么不自己搭一个shadowsocks服务端呢？更何况年付的价钱不比你购买账号贵！服务器还在自己手里，不怕隐私泄露。</p><h1 id="什么是vps"><a href="#什么是vps" class="headerlink" title="什么是vps"></a>什么是vps</h1><p>笔者理解也不深，感觉就是虚拟主机的升级版，可拥有独立ip，但又不是独立服务器，是一台服务器上利用虚拟化技术独立出来的单独机器，购买这台vps后，你自己就可以对这台机器做任意操作：重装系统（Linux，Windows），装任意软件，拥有root权限，可远程操控都不在话下。总之和一台远程服务器差不多。但是价格却远低于服务器价格。搬瓦工VPS的介绍翻译如下：</p><blockquote><p> 隶属于美国IT7公司旗下的一款低价OpenVZ VPS主机方案、2017年新增KVM VPS架构，尤其是6款便宜年付VPS，无论从性价比还是稳定性都非常适合大众VPS用户需求，我们可以用来建站、搭建上网环境</p></blockquote><p>官网：<a href="https://bandwagonhost.com/aff.php?aff=14794">性价比高*搬瓦工vps</a></p><p>笔者购买的是最便宜的年付19刀（人民币130左右）的512M内存，10G ssd硬盘，100G宽带方案，难能可贵的是搬瓦工vps：可使用<strong>支付宝</strong>支付，据说是2016年推出的新功能，之前只能使用PayPal支付。</p><hr><h1 id="购买搬瓦工VPS"><a href="#购买搬瓦工VPS" class="headerlink" title="购买搬瓦工VPS"></a>购买搬瓦工VPS</h1><ol><li>打开搬瓦工官网：<a href="https://bandwagonhost.com/aff.php?aff=14794">性价比高*搬瓦工vps</a></li><li>点击要购买的的套餐下方的 订购按钮“order Now”，<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.06.23.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.06.23.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li><li>进入如下图示界面，选择付账周期Billing Cycle（月付，季付，半年付，年付），和<br>节点Location（洛杉矶，佛罗里达等），洛杉矶的节点还行，比较稳定。最后点击Add to Cart加入购物车，之后下一个界面点击check out结账。<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.07.44.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.07.44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li><li>注册账号<br>有几点：</li></ol><ul><li>资料是否完全真实无所谓，姓名可以随意填</li><li>邮箱必须自己的，以免以后找回密码需要</li><li>国家、地区、省份必须真实</li><li>街道等详细地址你随意填写，电话也可以随意。不能用V&#x3D;P&#x3D;N软件更换IP购买，用真实的IP购买就可以。</li><li>Pay Method中选择Alipay即支付宝，勾选下方的协议</li><li>点击Complete Order结账</li><li>手机支付宝扫二维码，完事<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.20.39.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.20.39.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li></ul><h1 id="搬瓦工VPS安装shadowsocks服务端"><a href="#搬瓦工VPS安装shadowsocks服务端" class="headerlink" title="搬瓦工VPS安装shadowsocks服务端"></a>搬瓦工VPS安装shadowsocks服务端</h1><ol><li>点击图中的Client Area，登陆账号<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.23.57.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.23.57.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li><li>查看服务<br> <img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.25.16.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.25.16.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li><li>点击右边的KiviVM Control Panel进入vps控制面板<br> <img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.27.36.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.27.36.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></li><li>安装shadowsocks Server<br> <img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.29.14.png" class="lazyload" data-srcset="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.29.14.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="此处输入图片的描述"></li></ol><h1 id="ss客户端使用"><a href="#ss客户端使用" class="headerlink" title="ss客户端使用"></a>ss客户端使用</h1><p><a href="https://github.com/shadowsocks">ss客户端下载</a><br><a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E">ss客户端使用</a></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://b.lhuac.com/2/">https://b.lhuac.com/2/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;作为一名开发者，科学上网是一个很强的诉求，至今被-墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言&quot;&gt;&lt;a href=&quot;#作为一名开发者，科学上网是一个很强的诉求，至今被-墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言&quot; class=&quot;headerlink&quot; title=&quot;作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言&quot;&gt;&lt;/a&gt;作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外&lt;br&gt;
    
    </summary>
    
      <category term="科学上网" scheme="http://blog.michaelx.tech/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="科学上网" scheme="http://blog.michaelx.tech/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="Shadowsocks" scheme="http://blog.michaelx.tech/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04编译AOSP for Nexus/Pixel</title>
    <link href="http://blog.michaelx.tech/2017-03/Ubuntu-14-04%E7%BC%96%E8%AF%91AOSP-for-Nexus-Pixel/"/>
    <id>http://blog.michaelx.tech/2017-03/Ubuntu-14-04编译AOSP-for-Nexus-Pixel/</id>
    <published>2017-03-14T03:29:09.000Z</published>
    <updated>2022-12-02T03:10:42.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为你手中的Nexus-Pixel手机刷入自己的专属Rom前言"><a href="#为你手中的Nexus-Pixel手机刷入自己的专属Rom前言" class="headerlink" title="为你手中的Nexus,Pixel手机刷入自己的专属Rom前言"></a>为你手中的Nexus,Pixel手机刷入自己的专属Rom<br><span id="more"></span><br>前言</h1><p>虽说几年前博主在一家公司做机顶盒的时候总是需要编译Android源码，但是那时还没有手中的爱机：Nexus 6，又名shamu。今天我要为它刷入一个自己编译的Rom。拿起键盘就是干。</p><blockquote><p>笔者注：AOSP:Android Open Source Project，安卓开源项目</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>Ubuntu 14.04+</li><li>OpenJDK&#x2F;JDK</li><li>Nexus&#x2F;Pixel手机一部</li></ul><p>假设你已经有了一个较新的Ubuntu系统和一部谷歌亲儿子手机，下文将从安装jdk开始。</p><blockquote><p>本文作者MichaelX，博客地址：<a href="http://blog.csdn.net/xiong_it">http://blog.csdn.net/xiong_it</a> ，转载请注明出处。</p></blockquote><hr><h1 id="AOSP编译环境搭建"><a href="#AOSP编译环境搭建" class="headerlink" title="AOSP编译环境搭建"></a>AOSP编译环境搭建</h1><h2 id="安装OpenJDK"><a href="#安装OpenJDK" class="headerlink" title="安装OpenJDK"></a>安装OpenJDK</h2><blockquote><p><strong>警告</strong>：不要使用oracle jdk来编译较新（API 21+&#x2F;Android 5.0及以上）的AOSP，会在准备编译工作<strong>make</strong> <strong>clobber</strong>时出现错误提示.</p></blockquote><pre><code>Checking build tools versions...*************************************************************You asked for an OpenJDK based build but your version is java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment(build 1.8.0_121-b13)Java HotSpot (TM)64 bit Server VM(build 25.121-b13), mixed mode).*************************************************************build/core/main.mk:230: *** stop.</code></pre><p>关于<strong>JDK版本</strong>的选择：<strong>根据你想编译的Android版本来决定</strong></p><ul><li>AOSP最新源码: OpenJDK 8</li><li>Android 5.x (Lollipop) - Android 6.0 (Marshmallow):OpenJDK 7</li><li>Android 2.3.x (Gingerbread) - Android 4.4.x(KitKat):Java JDK 6</li><li>Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Java JDK 5</li></ul><p>博主想要编译的是Android 7.0，所以需要使用是OpenJDK 8。</p><p>博主是用的Ubuntu 14.04 LTS，可采取安装deb包或者添加ppa两种方式安装OpenOJDK 8：</p><ol><li>OpenJDK deb包下载:<a href="https://github.com/xiong-it/buildAOSP/tree/master/OpenJDK8">OpenJDK 8 on github</a></li><li>添加ppa方式安装OpenJDK<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line">$ sudo update-alternatives --config java</span><br><span class="line">$ sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>假如你Ubuntu是15.04或者更新的系统，可直接运行下列命令进行OpenJDK 8安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>Linux使用下列命令查看机器中所有jdk版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ michaelx@michaelx-ThinkPad:~/AOSP_NBD91Z$ update-java-alternatives -l</span><br><span class="line">// 打印出下面已安装的jdk版本</span><br><span class="line">java-1.8.0-openjdk-amd64 1069 /usr/lib/jvm/java-1.8.0-openjdk-amd64</span><br></pre></td></tr></table></figure><p>Linux设置默认JDK命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置默认为openjdk8，此处必须选用OpenJDK8</span><br><span class="line">$ sudo update-java-alternatives -s java-1.8.0-openjdk-amd64</span><br><span class="line">// 设置默认为oracle jdk8</span><br><span class="line">$ sudo update-java-alternatives -s java-8-oracle</span><br><span class="line">// 设置默认为oracle jdk7</span><br><span class="line">$ sudo update-java-alternatives -s java-7-oracle</span><br></pre></td></tr></table></figure><p>Ubuntu 14.04设置默认OpenJDK 8时出现一处警告提示：</p><pre><code>update-java-alternatives: plugin alternative does not exist: /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/IcedTeaPlugin.so</code></pre><p>该提示无需理会，可直接忽略。</p><p>查看Java版本，出现以下提示，说明jdk环境已经ok。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line"></span><br><span class="line">openjdk version &quot;1.8.0_111&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-3~14.04.1-b14)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode)</span><br></pre></td></tr></table></figure><p>如果实在切换不了默认jdk，就像博主一样，卸了oracle jdk吧。</p><h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>在你的Ubuntu 14(x64)上执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential \</span><br><span class="line">  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</span><br><span class="line">  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</span><br><span class="line">  libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure><p>会有些已经安装，有些无法安装，或者安装失败，无需理会，继续往下。其他系统版本系统请直接参考：<a href="https://source.android.com/source/initializing.html">Establishing a build environment</a></p><h2 id="配置USB访问权限"><a href="#配置USB访问权限" class="headerlink" title="配置USB访问权限"></a>配置USB访问权限</h2><p>ps：不知道这个干啥的，但是官方是这么建议的，为了让普通用户可访问usb设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -S -O - http://source.android.com/source/51-android.rules | sed &quot;s/&lt;username&gt;/$USER/&quot; | sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules</span><br></pre></td></tr></table></figure><hr><h1 id="安装repo"><a href="#安装repo" class="headerlink" title="安装repo"></a>安装repo</h1><p>安装repo以下载AOSP源码。repo是Google根据git开发来专门管理Android源码用的，具有断点续传的特性。其主要命令可参考：<a href="http://blog.csdn.net/xiong_it/article/details/45173987">git&#x2F;repo常用命令一览</a>。依次执行下面命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ mkdir bin</span><br><span class="line">$ PATH=~/bin:$PATH</span><br><span class="line"></span><br><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">$ chmod a+x ~/bin/repo # 给repo添加执行权限</span><br></pre></td></tr></table></figure><h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><p>由于需要下载Android源码，你需要事先准备好一个google的<a href="https://www.google.com/gmail/">gmail邮箱</a>。执行以下命令配置git用户名和gmail邮箱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;you@gmail.com&quot;</span><br></pre></td></tr></table></figure><p>配置Google的git cookies访问权限，以便大量下载aosp源码站点资源。<br><a href="https://android.googlesource.com/new-password">https://android.googlesource.com/new-password</a><br><img src="http://img.blog.csdn.net/20170312103501761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312103501761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="configure git"><br>复制框中的命令,粘贴到终端,执行。</p><hr><h1 id="下载AOSP源码"><a href="#下载AOSP源码" class="headerlink" title="下载AOSP源码"></a>下载AOSP源码</h1><p><strong>创建一个目录以存放Android源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/AOSP_NBD91Z # 目录名请自行定义，本文以AOSP_NBD91ZNBD91Z为例</span><br><span class="line">$ cd AOSP_NBD91Z</span><br></pre></td></tr></table></figure><p>根据手中的机器和以下两个连接进行<strong>repo分支选择</strong>：<br><a href="https://source.android.com/source/build-numbers.html">https://source.android.com/source/build-numbers.html</a><br><a href="https://developers.google.com/android/nexus/drivers">https://developers.google.com/android/nexus/drivers</a></p><p>AOSP源码编译默认是不适配驱动的，只适合模拟器运行，由于博主想要为Nexus 6编译，所以需要考虑驱动问题，根据上文第二个链接找到shamu的最新驱动，目前（20170307）最新的驱动支持到build NBD91Z，将<strong>驱动下载下来，留着备用</strong>。<br><img src="http://img.blog.csdn.net/20170312115424282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312115424282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>在第一个链接中找到对应的branch name（<strong>android-7.0.0_r29</strong>）。<br><img src="http://img.blog.csdn.net/20170312140527859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312140527859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"></p><p><strong>在AOSP本地目录初始化repo分支</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/AOSP_NBD91Z</span><br><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.0.0_r29</span><br></pre></td></tr></table></figure><p><strong>下载&#x2F;续传AOSP源码</strong><br>无论是第一次开始下载，还是中途断掉后接着续传下载，都是执行以下命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ repo sync</span><br></pre></td></tr></table></figure><p>之后就是漫长的等待了，该分支（android-7.0.0_r29）代码总共约80G（含版本管理文件.repo目录46G）。<br>这里提醒下各位，分区的时候一定记得至少至少至少给到120G啊，80G还不是最新分支的大小呢。编译后更加大得多：该分支编译出的out目录共30G左右。<br><img src="http://img.blog.csdn.net/20170312140830563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312140830563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>不过下载完成后，如果没什么版本控制的需要 .repo目录倒是可以删除掉，节省点硬盘空间。</p><hr><h1 id="编译AOSP预备工作"><a href="#编译AOSP预备工作" class="headerlink" title="编译AOSP预备工作"></a>编译AOSP预备工作</h1><p><strong>设置编译缓存（可选操作）</strong><br>可加速后续第二次编译，如需要，可在源码目录执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export USE_CCACHE=1</span><br><span class="line">$ export CCACHE_DIR=~/AOSP_NBD91Z/.ccache # 目录自定义</span><br><span class="line">$ prebuilts/misc/linux-x86/ccache/ccache -M 50G # 官方推荐50-100G</span><br></pre></td></tr></table></figure><p>更新环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"># 添加以下这行</span><br><span class="line">export USE_CCACHE=1</span><br><span class="line"></span><br><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure><p><strong>释放手机驱动</strong><br>将上述下载的几个驱动文件解压到<code>源码根目录</code>，解压后也就是几个脚本文件，依次执行，以释放驱动，画风大概如下<br><img src="http://img.blog.csdn.net/20170312141135768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312141135768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="释放shamu驱动"></p><p><img src="http://img.blog.csdn.net/20170312213814287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312213814287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="释放shamu驱动"></p><p><img src="http://img.blog.csdn.net/20170312184550739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312184550739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="释放shamu驱动"></p><p>共8大条款，几十个小条款，一行行回车按过去，心累啊。</p><blockquote><p>划重点：在执行驱动脚本后，会让你看一大长串协议，最后你需要输入：<strong>I ACCEPT</strong> 来同意驱动的协议，方可释放驱动文件。按回车按快了则提示你没有同意，驱动未释放成功。成功之后会多出一个vendor目录。</p></blockquote><p><strong>清理编译文件</strong><br>驱动释放完毕，先执行<code>make clobber</code>清理下编译后文件的目录，第一次编译其实博主觉得这个命令无所谓。</p><blockquote><p>相似命令：<code>make clean</code> 它清理out&#x2F;target&#x2F;product&#x2F;[product_name]目录。</p></blockquote><hr><h1 id="编译AOSP"><a href="#编译AOSP" class="headerlink" title="编译AOSP"></a>编译AOSP</h1><p><strong>准备好编译平台</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd AOSP_NBD91Z</span><br><span class="line">$ source build/envsetup.sh</span><br><span class="line"># or 或者，上面的命令和下面的命令等价</span><br><span class="line">$ . build/envsetup.sh</span><br></pre></td></tr></table></figure><p><strong>选择编译平台</strong><br>执行上述命令后方可执行这条命令<code>lunch</code><br><img src="http://img.blog.csdn.net/20170312141046014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312141046014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="lunch"><br>由于笔者手中是Nexus 6（shamu），所以果断选择了21</p><p><strong>关于几种模式的区别</strong></p><ul><li>user 正常模式，给普通用户用的</li><li>userdebug具备root权限和更多调试功能，其他和user模式无异</li><li>eng开发者的最佳选项，具有许多额外的调试工具</li></ul><p><strong>正式编译AOSP源码</strong><br>运行<code>make</code>进行编译，也可以使用-j选项指定并行编译线程数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 利用6个线程进行编译。官方建议的最快并行线程数量为：j16-j32之间。</span><br><span class="line">$ make -j6 </span><br><span class="line"></span><br><span class="line"># 请各位根据自身CPU性能量力而行。博主曾经使用-j16导致GUI界面和终端统统卡死，只能强制关机，心疼我的ssd硬盘30s。</span><br></pre></td></tr></table></figure><p>又是一次漫长的等待啊，如果不出什么问题，那么在<code>out/target/product/[product_name]/</code>目录下将会多出诸如system.img，recovery.img等等，就可以愉快的刷机了。<br><img src="http://img.blog.csdn.net/20170312215601142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312215601142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="build-aosp-successful"></p><p>下面是生成的各种镜像文件和其他。<br><img src="http://img.blog.csdn.net/20170312215818926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170312215818926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="out-dir-files"></p><hr><h1 id="编译AOSP遇到的问题"><a href="#编译AOSP遇到的问题" class="headerlink" title="编译AOSP遇到的问题"></a>编译AOSP遇到的问题</h1><p><strong>权限遭拒</strong><br>由于博客使用了外部硬盘作为out编译输出，<code>make</code>时提示Permission is denied。这时换成<code>sudo make</code>即可。</p><blockquote><p>使用外部磁盘做out输出：export OUT_DIR_COMMON_BASE&#x3D;&#x2F;media&#x2F;username&#x2F;外部磁盘路径&#x2F;out</p></blockquote><p><strong>内存不足</strong><br>由于笔者的内存只有4G，并且最开始没有分出swap分区，导致多次内存不足编译失败，有多种日志形式都表明内存不足：</p><p>第1种错误：<br><code>[ 34% 12287/35393] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Communication error with Jack server (52). Try &#39;jack-diagnose&#39; ninja: build stopped: subcommand failed. make: *** [ninja_wrapper] Error 1</code></p><p>第2种错误：<br><code>[ 82% 30024/36285] Aligning zip: out/target/product/shamu/obj/SHARED_LIBRARIES/libdlext_test_runpath_zip_zipaligned_intermediates/libdlext_test_runpath_zip_zipaligned.zip [ 82% 30025/36285] Import includes file: out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/import_includes [ 82% 30026/36285] target thumb C++: libverifier &lt;= bootable/recovery/asn1_decoder.cpp [ 82% 30027/36285] target thumb C++: libverifier &lt;= bootable/recovery/verifier.cpp [ 82% 30028/36285] Export includes file:  -- out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/export_includes [ 82% 30029/36285] target thumb C++: libverifier &lt;= bootable/recovery/ui.cpp ninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1</code></p><p>第3种错误：<br><code>FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Out of memory error (version 1.2-rc4 &#39;Carnac&#39; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)). GC overhead limit exceeded. Try increasing heap size with java option &#39;-Xmx&lt;size&gt;&#39;. Warning: This may have produced partial or corrupted output. [ 31% 11494/36285] host C++: libartd-compiler &lt;= art/compiler/optimizing/graph_visualizer.cc [ 31% 11494/36285] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/libprotobuf-java-nano_intermediates/classes.jack [ 31% 11494/36285] build out/target/common/obj/JAVA_LIBRARIES/sdk_v21_intermediates/classes.jack ninja: build stopped: subcommand failed.</code></p><p>第4种错误：<br><code>[  6% 2375/35393] target Java: icu4j (out/target/common/obj/JAVA_LIBRARIES/icu4j_intermediates/classes) Note: Some input files use or override a deprecated API. Note: Recompile with -Xlint:deprecation for details. Note: external/icu/icu4j/main/classes/core/src/com/ibm/icu/impl/Relation.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. [  6% 2394/35393] host C++: libLLVMMC_32 &lt;= external/llvm/lib/MC/MCDwarf.cppninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1</code></p><p>第5种错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[  5% 1883/35393] Docs droiddoc: out/target/common/docs/api-stubs</span><br><span class="line">FAILED: /bin/bash out/target/common/docs/api-stubs-timestamp.rsp</span><br><span class="line">OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bdb80000, 72876032, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"># Native memory allocation (mmap) failed to map 72876032 bytes for committing reserved memory.</span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"># /home/michaelx/AOSP_NBD91Z/hs_err_pid508.log</span><br><span class="line">[  5% 1883/35393] Docs droiddoc: out/target/common/docs/system-api-stubs</span><br><span class="line">DroidDoc took 27 sec. to write docs to out/target/common/docs/system-api-stubs</span><br><span class="line">ninja: build stopped: subcommand failed.</span><br><span class="line">make: *** [ninja_wrapper] Error 1</span><br></pre></td></tr></table></figure><p>解决内存不足的3个办法：</p><ol><li>增加机器内存</li><li>增加swap分区</li><li>修改prebuild&#x2F;sdk&#x2F;tools&#x2F;jack-admin文件</li></ol><p>第一种方式就不说了，给机器加根内存条，壕专享。<br>第二种方式：增加swap分区：<a href="http://hancj.blog.51cto.com/89070/197915">http://hancj.blog.51cto.com/89070/197915</a><br>第三种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 备份jack-admin</span><br><span class="line">$ cp prebuild/sdk/tools/jack-admin ~/Docments/jack-admin.original</span><br><span class="line"></span><br><span class="line"># 修改jack-admin文件</span><br><span class="line">$ vim prebuild/sdk/tools/jack-admin</span><br><span class="line"></span><br><span class="line"># start-server方法，笔者的jack-admin在443行，修改该方法中的一句话：</span><br><span class="line"># JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br><span class="line"># 改成下面这行,增加java堆大小。</span><br><span class="line">JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx8000M -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上增加的-Xmx8000M，表示允许java在运行时java堆使用最大不超过8000M内存，这个数值是笔者经历了多次测试得到的结果，2048M，4096M，依旧没通过编译，改成8000M后编译通过，可能跟笔者自身硬件限制有很大关系</p></blockquote><pre><code>另一种修改方式：修改jack-admin第29行的变量：JACK_SERVER_VM_ARGUMENTS=&quot;$&#123;JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation&#125;&quot;改成：JACK_SERVER_VM_ARGUMENTS=&quot;$&#123;JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation -Xmx8000M&#125;&quot;但是这种修改方式仍然不好使，编译失败了。</code></pre><p>笔者是尝试了第二，三种方式解决。</p><p><strong>jack-server无法运行</strong><br>错误日志如下：<br><code>[ 37% 13421/35393] Ensure Jack server is installed and started FAILED: /bin/bash -c &quot;(prebuilts/sdk/tools/jack-admin install-server prebuilts/sdk/tools/jack-launcher.jar prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar  2&gt;&amp;1 || (exit 0) ) &amp;&amp; (JACK_SERVER_VM_ARGUMENTS=\&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation\&quot; prebuilts/sdk/tools/jack-admin start-server 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update server prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 4.8.ALPHA 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-2.28.RELEASE.jar 2.28.RELEASE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-3.36.CANDIDATE.jar 3.36.CANDIDATE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-4.7.BETA.jar 4.7.BETA || exit 47 )&quot; Jack server already installed in &quot;/home/michaelx/.jack-server&quot; Launching Jack server java -XX:MaxJavaStackTraceDepth=0 -Djava.io.tmpdir=/tmp -Dfile.encoding=UTF-8 -XX:+TieredCompilation -cp /home/michaelx/.jack-server/launcher.jar com.android.jack.launcher.ServerLauncher Jack server failed to (re)start, try &#39;jack-diagnose&#39; or see Jack server log No Jack server running. Try &#39;jack-admin start-server&#39; No Jack server running. Try &#39;jack-admin start-server&#39; [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/coptccal.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/compactdecimalformat.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/cpdtrans.cpp ninja: build stopped: subcommand failed.</code></p><p>解决Jack server failed to (re)start办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /prebuild/sdk/tools/</span><br><span class="line"></span><br><span class="line">$ jack-admin stop-server</span><br><span class="line">$ jack-admin start-server</span><br></pre></td></tr></table></figure><p>和各路编译错误大战了7天7夜（真的是7天7夜呀，碰到的无数问题我都没写完呢），终于修成正果。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到了这里，相信大家都能轻松搞机了，如果有需要Nexus的刷机教程，请留言评论，下次出一篇Nexus的刷机过程。放2张Nexus 6刷机后的高清截图<br><img src="http://img.blog.csdn.net/20170313115421821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170313115421821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="首屏截图"></p><p><img src="http://img.blog.csdn.net/20170313115511697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170313115511697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="抽屉截图"></p><blockquote><p>本文原创作者:<a href="http://blog.csdn.net/xiong_it">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E6%9D%A5%E6%BA%90">http://blog.csdn.net/xiong_it.转载请注明来源</a></p></blockquote><p>欢迎光临：<a href="https://xiong-it.github.io/">MichaelX’s Blog</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>感谢<br>AOSP官网：<a href="https://source.android.com/source/initializing.html">https://source.android.com/source/initializing.html</a><br>AskUbuntu：<a href="http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-package">http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-package</a><br>CSDN:<a href="http://blog.csdn.net/brightming/article/details/49763515">http://blog.csdn.net/brightming/article/details/49763515</a></p><p>etc….</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为你手中的Nexus-Pixel手机刷入自己的专属Rom前言&quot;&gt;&lt;a href=&quot;#为你手中的Nexus-Pixel手机刷入自己的专属Rom前言&quot; class=&quot;headerlink&quot; title=&quot;为你手中的Nexus,Pixel手机刷入自己的专属Rom前言&quot;&gt;&lt;/a&gt;为你手中的Nexus,Pixel手机刷入自己的专属Rom&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Ubuntu" scheme="http://blog.michaelx.tech/tags/Ubuntu/"/>
    
      <category term="AOSP" scheme="http://blog.michaelx.tech/tags/AOSP/"/>
    
      <category term="Nexus" scheme="http://blog.michaelx.tech/tags/Nexus/"/>
    
      <category term="Pixel" scheme="http://blog.michaelx.tech/tags/Pixel/"/>
    
  </entry>
  
  <entry>
    <title>Android:BLE智能硬件开发详解</title>
    <link href="http://blog.michaelx.tech/2017-03/Android-BLE%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.michaelx.tech/2017-03/Android-BLE智能硬件开发详解/</id>
    <published>2017-03-14T03:23:18.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录"><a href="#前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录" class="headerlink" title="前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录"></a>前些年，智能硬件炒的挺火的，那今天，咱就来说说<strong>智能硬件那些事</strong><br><span id="more"></span><br>目录</h1><ul><li><strong>前言</strong></li><li><strong>BLE是个什么鬼</strong></li><li><strong>BLE中的角色分工</strong></li><li><strong>主要的关键词和概念</strong><ul><li>GATT(Generic Attribute Profile )</li><li>Characteristic</li><li>Service</li></ul></li><li><strong>Android如何使用BLE</strong><ul><li>蓝牙权限</li><li>APP和BLE外设交互流程</li></ul></li><li><strong>后记</strong><br/></li></ul><blockquote><p>本文作者MichaelX，博客地址：<a href="http://blog.csdn.net/xiong_it">http://blog.csdn.net/xiong_it</a> 转载请注明来源</p></blockquote><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些年，智能硬件炒的挺火的，那今天，咱就来说说<strong>智能硬件那些事</strong>。BLE是智能硬件的一种通讯方式，通过BLE连接，iOS &amp; Android手机和智能硬件就可以进行自定义的交互了。交互的体验如何，很大程度上取决于智能硬件的驱动工程师驱动写的好不好，以及App的代码质量如何。</p><p>笔者曾参与过多款BLE智能硬件的开发，许久不用，怕忘了，把自己的整理的一些知识记录与此，同时也希望能够给一些同学带来帮助。本文将尽力向读者讲清楚BLE是什么，以及在实际Android开发中该如何使用BLE。</p><p><strong>前方高能：</strong>文章有点长，笔者经历了好几次改版，也花费了好几个月的业余时间，读者可能需要点耐心。着急的读者可直接跳转至**<a href="http://blog.csdn.net/Xiong_IT/article/details/60966458#t8">Android如何使用BLE</a>**</p><h1 id="BLE是个什么鬼"><a href="#BLE是个什么鬼" class="headerlink" title="BLE是个什么鬼"></a>BLE是个什么鬼</h1><p>BLE：Bluetooth Low Energy,低功耗蓝牙。Android官方介绍如下：</p><blockquote><p>Android 4.3 (API Level 18) introduces built-in platform support for Bluetooth Low Energy in the central role and provides APIs that apps can use to discover devices, query for services, and read&#x2F;write characteristics. In contrast to Classic Bluetooth, Bluetooth Low Energy (BLE) is designed to provide significantly lower power consumption. This allows Android apps to communicate with BLE devices that have low power requirements, such as proximity sensors, heart rate monitors, fitness devices, and so on.</p></blockquote><p>什么意思呢？自从API18&#x2F;Android4.3开始，Android开始支持低功耗蓝牙并给APP提供了一套api调用。相比传统蓝牙来说，BLE技术旨在降低蓝牙功耗。至于我们Android开发者来说，要做的就是调用这套api，和具备蓝牙的智能硬件沟通，通过蓝牙读写操控智能硬件。</p><p>BLE技术允许APP和那些有着<strong>低功耗</strong>需求的BLE设备进行通讯，这些设备包括但不限于：距离传感器设备，心跳率检测仪，健身器材，智能穿戴等。</p><blockquote><p><strong>约定:文中提到的”外设”,”BLE外设”和”智能硬件”是等价的.请读者知悉.</strong></p></blockquote><hr><h1 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h1><blockquote><p>Once the phone and the activity tracker have established a connection, they start transferring GATT metadata to one another. Depending on the kind of data they transfer, one or the other might act as the server. For example, if the activity tracker wants to report sensor data to the phone, it might make sense for the activity tracker to act as the server. If the activity tracker wants to receive updates from the phone, then it might make sense for the phone to act as the server.</p></blockquote><p>在Android APP和BLE外设进行交互时,他们分别扮演两个角色.这两个角色是不固定的.<br>GATT server:发送数据的一方.<br>GATT client:接收数据的一方.<br>当APP向外设写入数据时,APP就是server,外设就是client;当APP读取外设数据时,APP就是client.外设就是server.</p><hr><h1 id="主要的关键词和概念"><a href="#主要的关键词和概念" class="headerlink" title="主要的关键词和概念"></a>主要的关键词和概念</h1><h2 id="GATT-Generic-Attribute-Profile"><a href="#GATT-Generic-Attribute-Profile" class="headerlink" title="GATT(Generic Attribute Profile )"></a>GATT(Generic Attribute Profile )</h2><blockquote><p>The GATT profile is a general specification for sending and receiving short pieces of data known as “attributes” over a BLE link. All current Low Energy APPlication profiles are based on GATT.</p></blockquote><p>这个是BLE通讯的基本协议,这个协议定义了BLE发送和接收一小段数据的规范,这些被传输的小段数据被称为”attributes”.</p><h2 id="Characteristic"><a href="#Characteristic" class="headerlink" title="Characteristic"></a>Characteristic</h2><blockquote><p>A characteristic contains a single value and 0-n descriptors that describe the characteristic’s value. A characteristic can be thought of as a type, analogous to a class. </p></blockquote><p>博主的理解中,”Characteristic”是BLE通讯之间的沟通”搬运工”,因为这是我们从智能硬件直接读写的东西,它依附于下文的Service存在，有自己的标志码：uuid。它『<strong>分为读取BLE外设数据的Characteristic &amp; 向BLE外设写入数据的Characteristic</strong>』。<br>下面章节中将用代码说话.</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><blockquote><p>A service is a collection of characteristics. For example, you could have a service called “Heart Rate Monitor” that includes characteristics such as “heart rate measurement.” </p></blockquote><p>此Service非彼Android四大组件中的彼Service,而是BluetoothGattService.这个Service是一个characteristics的集合,它可以理解为针对某个信号的通讯线路。</p><hr><h1 id="Android如何使用BLE"><a href="#Android如何使用BLE" class="headerlink" title="Android如何使用BLE"></a>Android如何使用BLE</h1><h2 id="蓝牙权限"><a href="#蓝牙权限" class="headerlink" title="蓝牙权限"></a>蓝牙权限</h2><p>使用BLE需要两个权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.BLUETOOTH&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.BLUETOOTH_ADMIN&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果你想要APP只适配具备BLE的手机,那个可以再添加一个硬件权限特性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.bluetooth_le&quot;</span> <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="APP和BLE外设交互流程"><a href="#APP和BLE外设交互流程" class="headerlink" title="APP和BLE外设交互流程"></a>APP和BLE外设交互流程</h2><p>APP和BLE外设交互的一个大概流程就是:</p><ol><li>BLE外设打开电源</li><li>APP初始化蓝牙</li><li>APP扫描周边BLE外设</li><li>APP连接到周边BLE外设</li><li>APP读写BLE外设</li><li>交互完成,APP向BLE外设写入关机&#x2F;待机指令(可选)</li><li>BLE外设关机</li><li>APP关闭本地蓝牙连接</li></ol><p>以下将逐步利用代码进行讲解APP和BLE外设交互.</p><h2 id="初始化BLE"><a href="#初始化BLE" class="headerlink" title="初始化BLE"></a>初始化BLE</h2><p>Java代码判断当前手机是否支持BLE低功耗蓝牙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断手机是否支持BLE</span></span><br><span class="line"><span class="keyword">if</span> (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123;</span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();</span><br><span class="line">    finish();<span class="comment">// 如果手机不支持BLE就关闭程序,仅供参考</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.</span></span><br><span class="line"><span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">final</span> <span class="type">BluetoothManager</span> <span class="variable">bluetoothManager</span> <span class="operator">=</span></span><br><span class="line">        (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</span><br><span class="line">mBluetoothAdapter = bluetoothManager.getAdapter();</span><br></pre></td></tr></table></figure><h2 id="跳转到系统蓝牙设置界面APP扫描周边BLE外设"><a href="#跳转到系统蓝牙设置界面APP扫描周边BLE外设" class="headerlink" title="跳转到系统蓝牙设置界面APP扫描周边BLE外设"></a>跳转到系统蓝牙设置界面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 验证蓝牙是否已打开,如果没打开就提示用户跳转打开.</span></span><br><span class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="literal">null</span> || !mBluetoothAdapter.isEnabled()) &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">enableBtIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(BluetoothAdapter.ACTION_REQUEST_ENABLE);</span><br><span class="line">    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br/><br>APP扫描周边BLE外设</h2><h2 id="需要实现一个BluetoothAdapter-LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下APP连接周边BLE外设"><a href="#需要实现一个BluetoothAdapter-LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下APP连接周边BLE外设" class="headerlink" title="需要实现一个BluetoothAdapter.LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下APP连接周边BLE外设"></a>需要实现一个BluetoothAdapter.LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param device 被手机蓝牙扫描到的BLE外设实体对象</span><br><span class="line"> * @param rssi 大概就是表示BLE外设的信号强度，如果为0，则表示BLE外设不可连接。</span><br><span class="line"> * @param scanRecord 被扫描到的BLE外围设备提供的扫描记录，一般没什么用</span><br><span class="line"> */</span><br><span class="line">public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) </span><br></pre></td></tr></table></figure><br>由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    private BluetoothAdapter mBluetoothAdapter;</span><br><span class="line">    private boolean mScanning;</span><br><span class="line">    private Handler mHandler;</span><br><span class="line"></span><br><span class="line">    // 每扫描10s休息一下</span><br><span class="line">    private static final long SCAN_PERIOD = 10000;</span><br><span class="line">    </span><br><span class="line">    private BluetoothAdapter.LeScanCallback mLeScanCallback =</span><br><span class="line">        new BluetoothAdapter.LeScanCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123;</span><br><span class="line">            // TODO 这里可以进行连接操作，连接操作见下一小节</span><br><span class="line">            if (device != null &amp;&amp; device.getName() != null &amp;&amp; device.getName().contain(&quot;你的产品名称&quot;))&#123;</span><br><span class="line">                // 连接设备</span><br><span class="line">                connectDevice(device);</span><br><span class="line">                // 停止扫描</span><br><span class="line">                scanLeDevice(false);</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    /**</span><br><span class="line">     * @param enable 是否进行扫描，false则停止扫描</span><br><span class="line">     */</span><br><span class="line">    private void scanLeDevice(final boolean enable) &#123;</span><br><span class="line">        if (enable) &#123;</span><br><span class="line">            // 利用Handler进行间歇性扫描，每次扫描时间：10s</span><br><span class="line">            mHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    mScanning = false;</span><br><span class="line">                    mBluetoothAdapter.stopLeScan(mLeScanCallback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, SCAN_PERIOD);</span><br><span class="line"></span><br><span class="line">            mScanning = true;</span><br><span class="line">            mBluetoothAdapter.startLeScan(mLeScanCallback);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 停止扫描</span><br><span class="line">            mScanning = false;</span><br><span class="line">            mBluetoothAdapter.stopLeScan(mLeScanCallback);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br/><br>APP连接周边BLE外设</h2><p>连接操作是进行手机和BLE外设交互的基础，请看下面connectDevice(BluetoothDevice)方法实现。</p><p>分两步走：</p><ol><li>判断该设备是否连接过，连接过则首先尝试直接连接：BluetoothGatt.connect()</li><li>首次连接或者直连失败使用：BluetoothDevice.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connectDevice</span><span class="params">(<span class="keyword">final</span> BluetoothDevice device)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="literal">null</span> || device == <span class="literal">null</span>) &#123;</span><br><span class="line">Log.w(TAG,</span><br><span class="line"><span class="string">&quot;BluetoothAdapter not initialized or unspecified address.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> device.getAddress();</span><br><span class="line"><span class="comment">// 之前连接过的设备，尝试直接连接。mBluetoothDeviceAddress表示刚才连接过的设备地址</span></span><br><span class="line"><span class="keyword">if</span> (mBluetoothDeviceAddress != <span class="literal">null</span></span><br><span class="line">&amp;&amp; address.equals(mBluetoothDeviceAddress)</span><br><span class="line">&amp;&amp; mBluetoothGatt != <span class="literal">null</span>) &#123;</span><br><span class="line">Log.d(TAG,</span><br><span class="line"><span class="string">&quot;Trying to use an existing mBluetoothGatt for connection.&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mBluetoothGatt.connect()) &#123;<span class="comment">// 连接成功</span></span><br><span class="line">    <span class="comment">// 修改连接状态变量</span></span><br><span class="line">mConnectionState = STATE_CONNECTING;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">BluetoothDevice</span> <span class="variable">remoteDevice</span> <span class="operator">=</span> mBluetoothAdapter.getRemoteDevice(address);</span><br><span class="line"><span class="keyword">if</span> (remoteDevice == <span class="literal">null</span>) &#123;</span><br><span class="line">Log.w(TAG, <span class="string">&quot;Device not found.  Unable to connect.&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">mBluetoothGatt = remoteDevice.connectGatt(context, <span class="literal">false</span>, mGattCallback);</span><br><span class="line">Log.d(TAG, <span class="string">&quot;Trying to create a new connection.&quot;</span>);</span><br><span class="line"><span class="comment">// 将当前连接上的设备地址赋值给连接过的设备地址变量</span></span><br><span class="line">mBluetoothDeviceAddress = address;</span><br><span class="line"><span class="comment">// 改变连接状态变量</span></span><br><span class="line">mConnectionState = STATE_CONNECTING;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>连接BEL外设时，需要一个实现回调接口以得到连接状态，BluetoothGattCallback大概实现如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private final BluetoothGattCallback mGattCallback =</span><br><span class="line">            new BluetoothGattCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123;</span><br><span class="line">            // 该方法在连接状态改变时回调，newState即代表当前连接状态</span><br><span class="line">            String intentAction;</span><br><span class="line">            // 连接上了</span><br><span class="line">            if (newState == BluetoothProfile.STATE_CONNECTED) &#123;</span><br><span class="line">                intentAction = ACTION_GATT_CONNECTED;</span><br><span class="line">                // 改变蓝牙连接状态变量</span><br><span class="line">                mConnectionState = STATE_CONNECTED;</span><br><span class="line">                // 发送自定义广播：连接上了</span><br><span class="line">                broadcastUpdate(intentAction);</span><br><span class="line">                // 当前外设相当于前面章节提到的Server角色：提供数据被手机读取</span><br><span class="line">                Log.i(TAG, &quot;Connected to GATT server.&quot;);</span><br><span class="line">                // 获取读/写服务：Service。该方法会触发下面的onServicesDiscovered()回调</span><br><span class="line">                mBluetoothGatt.discoverServices();</span><br><span class="line"></span><br><span class="line">            &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;// 断开连接了</span><br><span class="line">                intentAction = ACTION_GATT_DISCONNECTED;</span><br><span class="line">                mConnectionState = STATE_DISCONNECTED;</span><br><span class="line">                Log.i(TAG, &quot;Disconnected from GATT server.&quot;);</span><br><span class="line">                // 发送自定义广播：断开了连接</span><br><span class="line">                broadcastUpdate(intentAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        // 该方法在蓝牙服务被发现时回调。由上述的mBluetoothGatt.discoverServices()触发结果。</span><br><span class="line">        public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123;</span><br><span class="line">            // 发现服务。status表示发现服务的结果码</span><br><span class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);</span><br><span class="line">                // TODO 从发现的Service来找出读数据用的BluetoothGattCharacteristic和写数据用的BluetoothGattCharacteristic。</span><br><span class="line">                initReadAndWriteCharacteristic(gatt.getServices());</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;// 未发现服务</span><br><span class="line">                Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        // 读取操作的回调结果</span><br><span class="line">        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        // 写入操作的回调结果</span><br><span class="line">        public void onCharacteristicWrite(BluetoothGatt gatt,</span><br><span class="line">BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">&#125;;</span><br><span class="line">     ...</span><br><span class="line">    &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><br/>**找出读写"数据包"的"搬运工"**<p>下面是找出读写”搬运工”BluetoothGattCharacteristic的initReadAndWriteCharacteristic()代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BluetoothGattCharacteristic mReadCharacteristic;</span><br><span class="line">BluetoothGattCharacteristic mWriteCharacteristic;</span><br><span class="line"></span><br><span class="line">public void initReadAndWriteCharacteristic(</span><br><span class="line">List&lt;BluetoothGattService&gt; gattServices) &#123;</span><br><span class="line">if (gattServices == null)</span><br><span class="line">return;</span><br><span class="line">// 遍历所有的 GATT Services.</span><br><span class="line">for (BluetoothGattService gattService : gattServices) &#123;</span><br><span class="line">if (!gattService.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的Service的uuid，由你司智能外色的驱动工程师决定&quot;))</span><br><span class="line">    continue;</span><br><span class="line">List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics();</span><br><span class="line">// 遍历当前Service中所有的Characteristics.</span><br><span class="line">for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123;</span><br><span class="line"></span><br><span class="line">if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;&quot;这里是你期望的写数据的uuid，由你司驱动工程师决定&quot;&quot;)) &#123;</span><br><span class="line">mWriteCharacteristic = gattCharacteristic;</span><br><span class="line">&#125; else if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的读数据的uuid，由你司驱动工程师决定&quot;)) &#123;</span><br><span class="line">mReadCharacteristic = gattCharacteristic;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="至此，我们就拿到了可携带读写数据的“搬运工”-『mReadCharacteristic-amp-mWriteCharacteristic』，下面就可以和智能硬件进行交互了。APP读取BLE外设蓝牙数据"><a href="#至此，我们就拿到了可携带读写数据的“搬运工”-『mReadCharacteristic-amp-mWriteCharacteristic』，下面就可以和智能硬件进行交互了。APP读取BLE外设蓝牙数据" class="headerlink" title="至此，我们就拿到了可携带读写数据的“搬运工”-『mReadCharacteristic  &amp; mWriteCharacteristic』，下面就可以和智能硬件进行交互了。APP读取BLE外设蓝牙数据"></a>至此，我们就拿到了可携带读写数据的“搬运工”-『<strong>mReadCharacteristic  &amp; mWriteCharacteristic</strong>』，下面就可以和智能硬件进行交互了。<br><br/><br>APP读取BLE外设蓝牙数据</h2><h2 id="想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。APP向BLE外设写入数据"><a href="#想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。APP向BLE外设写入数据" class="headerlink" title="想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。APP向BLE外设写入数据"></a>想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 告诉”搬运工“我想知道BLE外设当前数据,将回调BluetoothGattCallback接口的onCharacteristicRead()方法</span><br><span class="line">mBluetoothGatt.readCharacteristic(mReadCharacteristic);</span><br><span class="line"></span><br><span class="line">// 读取BLE蓝牙数据操作的回调方法</span><br><span class="line"> @Override</span><br><span class="line">public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</span><br><span class="line">                // ”搬运工“把”数据包“搬出来了</span><br><span class="line">                byte[] data = characteristic.getValue();</span><br><span class="line">        // 根据驱动工程师给的协议文档，解析该数组，该处假设数组0位上表示心跳速率</span><br><span class="line">        int heartRateR = data[0];// 得到心跳速率，做相应UI更新和操作</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br><br/><br>APP向BLE外设写入数据</h2><p>比如说你想告诉BLE外设让他锁屏，或者进行某个动作，APP向操纵BLE外设时可通过以下方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 根据驱动工程师给的协议文档，组织一个数组命令</span><br><span class="line">byte[] data = getData();</span><br><span class="line">// 将该条命令“数据包”给“搬运工&quot;</span><br><span class="line">mWriteCharacteristic.setValue(data);</span><br><span class="line"></span><br><span class="line">// ”搬运工“将数据搬到BLE外设里面了，将回调BluetoothGattCallback接口的onCharacteristicWrite()方法</span><br><span class="line">mBluetoothGatt.writeCharacteristic(characteristic);</span><br><span class="line"></span><br><span class="line">// 向BLE蓝牙外设写入数据操作的回调方法</span><br><span class="line">@Override</span><br><span class="line">public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</span><br><span class="line">if(status == BluetoothGatt.GATT_SUCCESS) &#123;</span><br><span class="line">    // 命令写入成功，数据包成功写入BLE外设中</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>多说一句，其实，手机关闭外设也是一条写入命令，外设得到该命令后即进入省电待机状态，一般外设也可以通过开&#x2F;关机键彻底关机。</p></blockquote><br/>APP关闭蓝牙连接-----交互完了，不需要了，还是把APP蓝牙连接给断掉吧<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void close() &#123;</span><br><span class="line">    if (mBluetoothGatt == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    mBluetoothGatt.close();</span><br><span class="line">    mBluetoothGatt = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Android官方在SDK中提供了许多demo供开发者参考（1年前左右），其实关于BLE api调用也是有的,不过只涉及了蓝牙外设的连接,未涉及蓝牙数据读写.BLE官方demo路径:<code>User/AndroidSDK/samples/android-19/connectivity/BluetoothLeGatt</code><br>以上路径是笔者举例的路径,如果你的SDK目录下没有samples目录，现在（20170308）SDK Manager已经不开放sample下载了,请点击下载：<a href="https://pan.baidu.com/s/1o87ASJK">android-sample-api19</a> 文件提取密码: y87g</p><blockquote><p>本文原创作者:<a href="http://blog.csdn.net/xiong_it">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E6%9D%A5%E6%BA%90">http://blog.csdn.net/xiong_it.转载请注明来源</a></p></blockquote><p>欢迎光临：<a href="https://xiong-it.github.io/">MichaelX’s Blog</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms">https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录&quot;&gt;&lt;a href=&quot;#前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录&quot; class=&quot;headerlink&quot; title=&quot;前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录&quot;&gt;&lt;/a&gt;前些年，智能硬件炒的挺火的，那今天，咱就来说说&lt;strong&gt;智能硬件那些事&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="BLE" scheme="http://blog.michaelx.tech/tags/BLE/"/>
    
      <category term="智能硬件" scheme="http://blog.michaelx.tech/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：模板方法模式</title>
    <link href="http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android：模板方法模式/</id>
    <published>2017-02-10T17:16:27.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言"><a href="#今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言" class="headerlink" title="今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言"></a>今天给大家分享的是《设计模式Android篇：模板方法模式》。<br>其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。<br><span id="more"></span><br>前言</h1><p>今天给大家分享的是《设计模式Android篇：模板方法模式》。<br>其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。<br>点击此处查看<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》</a>系列其他文章。</p><pre><code>本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。</code></pre><h1 id="模板方式模式定义"><a href="#模板方式模式定义" class="headerlink" title="模板方式模式定义"></a>模板方式模式定义</h1><blockquote><p>模板方法模式(Template method pattern):定义一个操作中的算法框架，而将一些步骤延迟到子类中实现，使得子类可以不改变算法结构即可重新定义该算法的某些特定步骤</p></blockquote><p>以上定义有两个关键词</p><ol><li>算法框架：其本质是一个方法，也就是模板方法，它的调用会依次执行一些特定的步骤</li><li>特定步骤：其本质一系列抽象的方法，交由子类实现，以重新定义该算法细节</li></ol><h1 id="模板方法的UML类图"><a href="#模板方法的UML类图" class="headerlink" title="模板方法的UML类图"></a>模板方法的UML类图</h1><p><img src="http://img.blog.csdn.net/20170209003325599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170209003325599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="模板方法的UML类图"></p><p>templateMethod：模板方法<br>methodA,methodB：特定步骤</p><h1 id="模板方法示例代码"><a href="#模板方法示例代码" class="headerlink" title="模板方法示例代码"></a>模板方法示例代码</h1><p>基类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">public void templateMethod() &#123;</span><br><span class="line">methodA();</span><br><span class="line"></span><br><span class="line">methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void abstract methodA();</span><br><span class="line"></span><br><span class="line">protected void abstract methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ConcreteClassA extends AbstractClass &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void abstract methodA() &#123;</span><br><span class="line">System.out.println(&quot;ConcreteClassA.do something.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void abstract methodB() &#123;</span><br><span class="line">System.out.println(&quot;ConcreteClassA.do other thing.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ConcreteClassB extends AbstractClass &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void abstract methodA() &#123;</span><br><span class="line">System.out.println(&quot;ConcreteClassB.do something.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void abstract methodB() &#123;</span><br><span class="line">System.out.println(&quot;ConcreteClassB.do other thing.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Android源码中模板方法模式"><a href="#Android源码中模板方法模式" class="headerlink" title="Android源码中模板方法模式"></a>Android源码中模板方法模式</h1><p>在Android的api源码中，给我们提供了一个执行异步任务的类AsyncTask，其用法d大致如下</p><ol><li>写一个自己的异步任务类（比如叫DownloadTask）继承自AsyncTask，主要复写onPreExecute(),doInBackground(),onPostExecute()等。</li><li>执行downloadTask</li></ol><p>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new DownloadTask().execute(url);</span><br></pre></td></tr></table></figure><p>我们发现只要调用了execute（Params…）后，AsyncTask自动调用了各个回调方法了，onPreExecute(),doInBackground(),onPostExecute()等，其实这就是<strong>模板方法模式</strong>！下面我们通过一个android开发案例来弄懂模板方法。</p><h1 id="Android开发中的模板方式模式实践"><a href="#Android开发中的模板方式模式实践" class="headerlink" title="Android开发中的模板方式模式实践"></a>Android开发中的模板方式模式实践</h1><p>Activity作为四大组件之首，是我们经常要使用到的，除非你的app不用和用户进行UI交互。<br>那在多个Activity中，我们通常在onCreate()做一些程序化的事情</p><ul><li>初始化控件</li><li>获取网络&#x2F;数据库数据</li><li>注册事件监听</li><li>注册广播</li><li>等等</li></ul><p>在onDestroy()中</p><ul><li>反注册广播</li><li>资源释放等</li></ul><p>这时我们通常可以使用模板方法模式来抽象出一个BaseActityBaseFragment类似，不展开分析。实例代码如下</p><p>先写一个基类BaseActity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseActivity extends Activity &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">initView();</span><br><span class="line"></span><br><span class="line">initData();</span><br><span class="line"></span><br><span class="line">initEvent();</span><br><span class="line"></span><br><span class="line">registerBroadcast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 初始化视图控件</span><br><span class="line">     */</span><br><span class="line">protected abstract void initView();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 初始化数据</span><br><span class="line">     */</span><br><span class="line">protected abstract void initData();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 初始化点击长按等事件</span><br><span class="line">     */</span><br><span class="line">protected abstract void initEvent();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 注册广播接收者</span><br><span class="line">     */</span><br><span class="line">protected void registerBroadcast() &#123;</span><br><span class="line">// 子类可以选择性复写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">super.onDestroy();</span><br><span class="line"></span><br><span class="line">unRegisterBroadcast();</span><br><span class="line"></span><br><span class="line">releaseMemory();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">     * 注销广播接收者</span><br><span class="line">     */</span><br><span class="line">protected void unRegisterBroadcast() &#123;</span><br><span class="line">// 子类可以选择性复写</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * 做些释放对象引用等其他操作以释放内存</span><br><span class="line">     */</span><br><span class="line">protected abstract void releaseMemory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随手写一个实现类MyActivity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends BaseActivity &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void initView() &#123;</span><br><span class="line">setContentView(resId);</span><br><span class="line">// TODO findViewById();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void initData() &#123;</span><br><span class="line">// TODO 访问数据库/网络获取数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void initEvent() &#123;</span><br><span class="line">// TODO setOnClickListener</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void releaseMemory() &#123;</span><br><span class="line">// TODO 把一些手动释放的对象值设为null</span><br><span class="line">someObj = null;// and so on.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再有一个其他Activity代码也是如此编写，以BaseActivity的onCreate(),onDestroy()为模板方法（算法框架），initView(),initData(),initEvent()等方法为特定步骤，利用模板方法构建了一个较好的基类，子类无需修改BaseActivity的算法框架，不同的Activity只需复写这些特定步骤即重新定义这些特定的细节步骤。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完这篇《Design Patterns in Android：策略模式》，是不是很多人恍然大悟，原来模板方法就是这样啊！<br>当编写一个方法时，其中包含了某些特定的步骤时，就可以考虑使用模板方法模式了。</p><p>好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》（设计模式Android篇）</a>系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言&quot;&gt;&lt;a href=&quot;#今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言&quot; class=&quot;headerlink&quot; title=&quot;今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言&quot;&gt;&lt;/a&gt;今天给大家分享的是《设计模式Android篇：模板方法模式》。&lt;br&gt;其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="模板方法模式" scheme="http://blog.michaelx.tech/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Template Method" scheme="http://blog.michaelx.tech/tags/Template-Method/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：策略模式</title>
    <link href="http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android：策略模式/</id>
    <published>2017-02-07T03:39:33.000Z</published>
    <updated>2022-12-02T03:10:42.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？-新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。-本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言"><a href="#刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？-新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。-本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言" class="headerlink" title="刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言"></a>刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。<br><span id="more"></span><br>前言</h2><p>刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？<br>新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。<br>点击此处查看<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》</a>系列其他文章。</p><pre><code>本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。</code></pre><h2 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h2><blockquote><p>策略模式(Strategy pattern)：定义一组算法，将其各个封装，并且使他们有交换性。</p></blockquote><p>策略模式好处在于使得算法在用户使用的时候能独立的改变，单一的修改，并且有良好扩展性。</p><pre><code>算法：指的是各个策略的实现逻辑，而非算法领域的数据算法。</code></pre><h2 id="策略模式UML类图"><a href="#策略模式UML类图" class="headerlink" title="策略模式UML类图"></a>策略模式UML类图</h2><p><img src="http://img.blog.csdn.net/20170206191558604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170206191558604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="策略模式UML类图"></p><p><strong>策略模式各角色讲解</strong></p><ul><li>IStrategy：策略基类（接口或者抽象类），定义子策略需要实现的方法，比如excute()，该方法取决于客户端代码（高层代码）需要该策略实现什么功能，子类则实现该方法，封装自己的算法，供外部调用。</li><li>Context：此Context，非彼（Android中的）Context，它持有IStrategy真实的实例对象，提供给客户端调用IStrategy时的上下文调度者。</li><li>ConcreteStrategyA：实现父类IStrategy的方法，封装自身算法逻辑。</li><li>ConcreteStrategyB：同上</li></ul><h2 id="策略模式的示例代码"><a href="#策略模式的示例代码" class="headerlink" title="策略模式的示例代码"></a>策略模式的示例代码</h2><p>IStrategy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteStrategyA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;1.我是ConcreteStrategyA的算法实现&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteStrategyB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;2.我是ConcreteStrategyB的算法实现&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context上下文角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">private</span> IStrategy strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">excute</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.strategy.excute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，下面是就是客户端代码，描述了如何使用策略模式<br>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">Context context;</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">context.excute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// context = new Context(new ConcreteStrategyB());</span></span><br><span class="line"><span class="comment">// context.excute();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，客户端需要什么策略就new什么策略，完全取决于客户端需求，而且如果策略A出现问题，修改策略A就是了，和其他地方完全无关，如果现有策略不符合需求，再实现一个ConcreteStrategyA即可。</p><h2 id="Android源码中的策略模式"><a href="#Android源码中的策略模式" class="headerlink" title="Android源码中的策略模式"></a>Android源码中的策略模式</h2><p><strong>大家在使用<a href="https://developer.android.com/guide/topics/graphics/view-animation.html">Animation</a>动画时，可以给Animation对象设置不同的插值器（Interpolator）来实现动画快慢速度动态效果。</strong></p><p>比如：<br>LinearInterpolator，线性插值器，实现匀速动画<br>AccelerateDecelerateInterpolator：加速减速插值器，实现开始加速，结尾时减速的动画</p><p>BaseInterpolator类：Interpolator的实现类，就是速度插值器策略的基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An abstract class which is extended by default interpolators.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseInterpolator</span> <span class="keyword">implements</span> <span class="title class_">Interpolator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> mChangingConfiguration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChangingConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mChangingConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setChangingConfiguration</span><span class="params">(<span class="type">int</span> changingConfiguration)</span> &#123;</span><br><span class="line">        mChangingConfiguration = changingConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Animation：Context上下文角色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animation implements Cloneable &#123;</span><br><span class="line">// ...</span><br><span class="line">// 省略无关代码</span><br><span class="line">// ...</span><br><span class="line">private Interpolator mInterpolator;</span><br><span class="line">/**</span><br><span class="line">     * Sets the acceleration curve for this animation. Defaults to a linear</span><br><span class="line">     * interpolation.</span><br><span class="line">     *</span><br><span class="line">     * @param i The interpolator which defines the acceleration curve</span><br><span class="line">     * @attr ref android.R.styleable#Animation_interpolator</span><br><span class="line">     */</span><br><span class="line">    public void setInterpolator(Interpolator i) &#123;</span><br><span class="line">        mInterpolator = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinearInterpolator等子类就实现了各自速度快慢的算法逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@HasNativeInterpolator</span><br><span class="line">public class LinearInterpolator extends BaseInterpolator &#123;</span><br><span class="line"></span><br><span class="line">    public LinearInterpolator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LinearInterpolator(Context context, AttributeSet attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getInterpolation(float input) &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们给一个ImageView添加View动画</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ImageView view;</span><br><span class="line">Animation animation = getResources().getAnimation(R.anim.pop_anim);</span><br><span class="line">// 给view的动画设置一个插值器策略</span><br><span class="line">animation.setInterpolator(new LinearInterpolator());</span><br><span class="line">view.startAnimation(animation);</span><br></pre></td></tr></table></figure><h2 id="Android开发中的策略模式实践"><a href="#Android开发中的策略模式实践" class="headerlink" title="Android开发中的策略模式实践"></a>Android开发中的策略模式实践</h2><p>需求，现在你开发的Android app需要实现盈利，PM经过一番规划，想要你接入<a href="http://blog.csdn.net/xiong_it/article/details/51685033">微信支付</a>，<a href="http://blog.csdn.net/xiong_it/article/details/51819559">支付宝支付</a>，银联支付等移动端通用支付方式。</p><p>这个功能好实现，接入相关支付SDK即可，问题就在如何优雅的实现这个功能呢？</p><blockquote><p>延伸阅读：<br><a href="http://blog.csdn.net/xiong_it/article/details/51685033">《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》</a><br><a href="http://blog.csdn.net/xiong_it/article/details/51819559">《 Android App支付系列（二）：支付宝SDK接入详细指南(附官方支付demo)》</a></p></blockquote><p>以下是笔者是实现，供各位读者参考。</p><ul><li>PayActivity：客户端角色，支付方式选择界面</li><li>AbsPayStrategy：作为支付策略基类，定义了一个pay方法</li><li>PayContext：上下文角色，用来封装支付AbsPayStrategy对象</li><li>WeChatPayStrategy：封装了微信支付算法逻辑</li><li>ALiPayStrategy：封装了支付宝支付算法逻辑</li><li>BankCardPayStrategy：封装了银行卡支付算法逻辑</li></ul><p><strong>支付功能的示意代码</strong><br>AbsPayStrategy的实际实现应该为抽象类，它需要持有Activity对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsPayStrategy</span> &#123;</span><br><span class="line"><span class="comment">// private Activity mActivity;</span></span><br><span class="line"><span class="comment">// 本策略主要就是实现支付功能</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>Context上下文角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayContext</span> &#123;</span><br><span class="line"><span class="keyword">private</span> AbsPayStrategy mPayStrategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PayContext</span><span class="params">(AbsPayStrategy payStrategy)</span> &#123;</span><br><span class="line">mPayStrategy = payStrategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">mPayStrategy.pay();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>微信支付策略实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信支付策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPayStrategy</span> <span class="keyword">implements</span> <span class="title class_">AbsPayStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 此处封装微信支付逻辑</span></span><br><span class="line"><span class="comment">// 具体请参考笔者的博文《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支付宝支付策略实现 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 支付宝支付策略</span><br><span class="line"> */</span><br><span class="line">public class ALiPayStrategy  implements AbsPayStrategy &#123;</span><br><span class="line"></span><br><span class="line">public void pay() &#123;</span><br><span class="line">// 此处封装支付宝支付逻辑</span><br><span class="line">// 具体请参考笔者的博文《 Android App支付系列（二）：支付宝支付SDk接入详细指南(附官方支付demo)》</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的客户端代码，此处为PayActivity</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class PayActivity extends Activity implements View.OnclickListener&#123;</span><br><span class="line"></span><br><span class="line">private PayContext mPayContext;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onClick(View view) &#123;</span><br><span class="line">switch(v.getId()) &#123;// 客户端来决定使用哪种支付策略</span><br><span class="line">case R.id.wechat_pay:</span><br><span class="line">mPayContext = new PayContext(new WechatPayStrategy());</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case R.id.wechat_pay:</span><br><span class="line">mPayContext = new PayContext(new ALiPayStrategy());</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case R.id.wechat_pay:</span><br><span class="line">mPayContext = new PayContext(BankCardPayStrategy());</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">mPayContext = new PayContext(new WechatPayStrategy());</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">// 利用实际的支付策略对象进行支付</span><br><span class="line">mPayContext.pay();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了一个app内的支付功能，如果微信支付出现问题了，改动微信支付策略代码，支付宝支付出现问题，改动想要实现即可，职责单一。</p><p>如果PM有一天说：我们需要接入百付宝，京东支付。怎么办？<br>简单啊，实现相应的支付策略即可，完美适应需求变更，实现功能扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果在开发某功能时，可能出现多种平等的选择，可以考虑使用策略模式实现。</p><p>好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》</a>（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？-新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。-本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言&quot;&gt;&lt;a href=&quot;#刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？-新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。-本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言&quot; class=&quot;headerlink&quot; title=&quot;刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言&quot;&gt;&lt;/a&gt;刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="策略模式" scheme="http://blog.michaelx.tech/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Strategy" scheme="http://blog.michaelx.tech/tags/Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：单例模式</title>
    <link href="http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android：单例模式/</id>
    <published>2017-01-17T08:11:02.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是《Design-Patterns-in-Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言"><a href="#这是《Design-Patterns-in-Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言" class="headerlink" title="这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言"></a>这是<a href="http://blog.csdn.net/Xiong_IT/article/details/54574020">《Design Patterns in Android》</a>系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。<br>本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用<br><span id="more"></span><br>前言</h1><p>这是<a href="http://blog.csdn.net/Xiong_IT/article/details/54574020">《Design Patterns in Android》</a>系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。<br>本系列《设计模式Android篇》博文将遵循以下模式，循序渐进的向读者讲解设计模式在Android开发的实践应用：</p><ol><li><p>给出设计模式的定义和使用场景</p></li><li><p>给出设计模式的UML类图</p></li><li><p>给出该设计模式的简单Java代码</p></li><li><p>给出该设计模式在Android源码中的应用分析</p></li><li><p>给出该设计模式在Android应用开发中的实践</p><p>本文原创作者xiong_it，博客链接：<a href="http://blog.csdn.net/xiong_it">http://blog.csdn.net/xiong_it</a>，转载请注明出处。</p></li></ol><h1 id="单例模式定义"><a href="#单例模式定义" class="headerlink" title="单例模式定义"></a>单例模式定义</h1><blockquote><p>单例模式(Singleton pattern):确保一个类只有一个实例，并提供对该实例的全局访问。</p></blockquote><p>根据其定义，它的使用场景：当你需要创建一个对象，但是创建这个对象时需要消耗大量的系统资源，或者这个对象迫于某种原因只能在内存中存在一个实例的时候，单例模式也许是个不错的创建方案。</p><h1 id="单例模式UML类图"><a href="#单例模式UML类图" class="headerlink" title="单例模式UML类图"></a>单例模式UML类图</h1><p><img src="http://img.blog.csdn.net/20170116175312086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170116175312086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="这里写图片描述"><br>Singleton类作为单例类，它耦合了自身成员变量，并对外提供了一个公开方法getInstance()对instance对象的全局访问。</p><h1 id="单例模式代码示例"><a href="#单例模式代码示例" class="headerlink" title="单例模式代码示例"></a>单例模式代码示例</h1><p>众所周知，单例模式有多个变种，但是最常见的还是“饿汉式”及“懒汉式”2种。本处示例代码以线程安全的饿汉式举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">sInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">sInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式注意事项主要有3点：</p><ul><li>如果处于多线程环境，注意保持线程安全，不然就无法保证单例了</li><li>单例模式的默认构造方法的修饰符需改为private，只能类内部访问，确保外部不能直接new出该实例</li><li>单例模式需要提供一个全局访问入口，这个入口通常以getInstance()的public静态方法形式呈现</li></ul><h1 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h1><p>InputMethodManager是用来管理输入法和软键盘状态的关键类，它就是源码中一个单例模式应用的典型案例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final classs InputMethodManager &#123;</span><br><span class="line"></span><br><span class="line">/*...</span><br><span class="line">省略代码，保留关键代码</span><br><span class="line">...*/</span><br><span class="line">static InputMethodManager sInstance;</span><br><span class="line"></span><br><span class="line">InputMethodManager(IInputMethodManager service, Looper looper) &#123;</span><br><span class="line">        mService = service;</span><br><span class="line">        mMainLooper = looper;</span><br><span class="line">        mH = new H(looper);</span><br><span class="line">        mIInputContext = new ControlledInputConnectionWrapper(looper,</span><br><span class="line">                mDummyInputConnection, this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">     * Retrieve the global InputMethodManager instance, creating it if it</span><br><span class="line">     * doesn&#x27;t already exist.</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public static InputMethodManager getInstance() &#123;</span><br><span class="line">        synchronized (InputMethodManager.class) &#123;</span><br><span class="line">            if (sInstance == null) &#123;</span><br><span class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</span><br><span class="line">                sInstance = new InputMethodManager(service, Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            return sInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以看到，InputMethodManager中有一个非公开的静态成员变量sInstance,它的构造方法也是非公开的，但是它对外（framwork层）提供了一个public的静态方法getInstance(Context)来对外提供单例对象，当该对象不存在时，就通过进程间通讯创建一个对象。<br>我们试想一下，假如它不是单例的话，在不同的应用中大家都可以自由创建该对象，该对象又极容易造成内存泄漏，创建N个InputMethodManager实例的话，你的Android手机该卡成什么鬼样子？？</p><blockquote><p>延伸阅读:<a href="https://zhuanlan.zhihu.com/p/20828861">《Android InputMethodManager 导致的内存泄露及解决方案》</a></p></blockquote><p>所以说，InputMethodManager做成单例是一个明智的选择，实际上，除了InputMethodManager，直接操作系统资源的许多??Manager都是采用了单例模式来创建，比如AccessibilityManager，InputManager，LayoutInflater，BulutoothManager等。<br>不过他们的单例模式实现多种多样，其中LayoutInflater及许多其他Manager是采用集合缓存的形式的实现，第一次getSystemService(String)获取LayouInflater对象时，系统会通过ServiceFetcher创建一个对象并缓存到系统服务列表中，第二次获取时，直接从列表中得到该对象，并不再二次创建，确保单例。</p><h1 id="Android开发中的单例实践"><a href="#Android开发中的单例实践" class="headerlink" title="Android开发中的单例实践"></a>Android开发中的单例实践</h1><p>大家用过Universal-Image-Loader吗？没用过也没关系，使用<a href="https://github.com/nostra13/Android-Universal-Image-Loader">UIL</a>加载一张图片非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImageLoader.getInstance().displayImage(imageUrl, imageView);</span><br></pre></td></tr></table></figure><p>很眼熟，对不对？其实，这里ImageLoader对象的创建就是采用了单例模式的实现。<br>假如它不是单例实现呢？每次用都初始化一次吗？每次都创建一个新的对象吗？显然这是很浪费资源的一件事，所以ImageLoader是采用了单例模式来创建一个对象，以后用的时候还是复用那个对象，保证了UIL API的易用性，同时也兼顾了系统资源的合理利用。<br>ImageLoader的单例实现代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ImageLoader &#123;</span><br><span class="line">/*</span><br><span class="line">...</span><br><span class="line">省略代码，保留关键代码</span><br><span class="line">...</span><br><span class="line">*/</span><br><span class="line">private volatile static ImageLoader instance;</span><br><span class="line"></span><br><span class="line">protected ImageLoader() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Returns singleton class instance */</span><br><span class="line">public static ImageLoader getInstance() &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">synchronized (ImageLoader.class) &#123;</span><br><span class="line">if (instance == null) &#123;</span><br><span class="line">instance = new ImageLoader();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>volatile关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全。</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当你的某个类多次创建很耗资源，或者你的某个类对象你只希望它存在一个实例对象在内存中时，请考虑单例模式。</p><p>好了，今天的《设计模式Android篇：单例模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020">《Design Patterns in Android》</a>（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这是《Design-Patterns-in-Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言&quot;&gt;&lt;a href=&quot;#这是《Design-Patterns-in-Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言&quot; class=&quot;headerlink&quot; title=&quot;这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言&quot;&gt;&lt;/a&gt;这是&lt;a href=&quot;http://blog.csdn.net/Xiong_IT/article/details/54574020&quot;&gt;《Design Patterns in Android》&lt;/a&gt;系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。&lt;br&gt;本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="单例模式" scheme="http://blog.michaelx.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Singleton" scheme="http://blog.michaelx.tech/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：目录纲要</title>
    <link href="http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BA%B2%E8%A6%81/"/>
    <id>http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android：目录纲要/</id>
    <published>2017-01-17T07:14:34.000Z</published>
    <updated>2022-12-02T03:10:42.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继<a href="http://blog.csdn.net/xiong_it/article/details/53467684">《设计模式系列：OOP设计6大原则》</a>之后，博主自此将“间歇性”更新《Design Patterns in Android》（设计模式Android篇），旨在总结自己作为一名Android开发者，在摸索设计模式的过程中爬过的坑，因为很多设计模式的博文，书籍都是针对Java场景的，为了帮助一些Android开发者更贴切的理解和应用设计模式，博文将描述在Android源码中存在的设计模式，以及Android项目如何实践设计模式，将笔者在Android项目实践这些设计模式的心得体会，所得所想以文字的形式展现在读者朋友的眼前，也希望能够和广大的读者有更多的交流，促使自身进步。</p><blockquote><p>间歇性：<br>1、笔者对于23种设计模式也不是全部了解,并没有全部实践过，只能根据自己一些经验来描述一些实践过或者接触过的模式<br>2、笔者中途也会更新其他博文，与读者分享</p></blockquote><pre><code>本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。</code></pre><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>在分享设计模式in Android之前，我们先来看下“设计模式”的定义</p><blockquote><p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。-<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%29">维基百科《设计模式 (计算机)》</a></p></blockquote><p>设计模式这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。并在1994年，埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides“四人帮”（Gang of Four，GoF）著成《设计模式：可复用面向对象软件的基础》为人所熟知并开始广泛流传。</p><p>也就是说，设计模式是一种软件编写过程中，解决编程问题的一种可复用的，有规矩可遵循的方案。</p><p>快速了解常用23中设计模式，<a href="http://blog.csdn.net/xiong_it/article/details/43445799">《设计模式教你追MM》</a></p><h1 id="23种设计模式分类"><a href="#23种设计模式分类" class="headerlink" title="23种设计模式分类"></a>23种设计模式分类</h1><p>根据设计模式的使用场景，大概可分为3类：</p><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>处理如何创建实例、对象。</p><ul><li><a href="http://blog.csdn.net/xiong_it/article/details/54575474">单例模式(Singleton pattern)</a></li><li>原型模式(Prototype pattern)</li><li>建造者&#x2F;构造器模式(Builder Pattern)</li><li>工厂方法模式(Factory Method pattern)</li><li>抽象工厂模式(Abstact Factory)</li></ul><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><p>处理类及对象的复合关系。</p><ul><li>适配器模式(Adapter pattern)</li><li>桥接模式(Bridge pattern)</li><li>组合模式(Composite pattern)</li><li>装饰模式(Decorator pattern)</li><li>享元模式(Flyweight pattern)</li><li>代理模式(Proxy pattern)</li></ul><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><p> 处理类&#x2F;对象之间的转换，通讯。</p><ul><li><a href="http://blog.csdn.net/xiong_it/article/details/54574746">策略模式(Strategy pattern)</a></li><li><a href="http://blog.csdn.net/xiong_it/article/details/54575479">模板方法模式(Template method pattern)</a></li><li>职责链模式(Chain-of-responsibility pattern)</li><li>命令模式(Command pattern)</li><li>解释器模式(Interpreter pattern)</li><li>迭代器模式(Iterator pattern)</li><li>仲裁器&#x2F;中介者模式(Mediator pattern)</li><li>备忘录模式(Memento pattern)</li><li>观察者(模式Observer pattern)</li><li>状态模式(State pattern)</li><li>参观者&#x2F;访问者模式(Visitor)</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如上，23种设计模式，各有各的使用场景，应用适当，可以使得代码扩展性大大提高，有利于后期需求变更和功能扩展及代码维护，带有链接的模式表示笔者已有介绍该模式在Android开发中的相关博文。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%29">《设计模式（计算机）》</a>，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80">《设计模式：可复用面向对象软件的基础》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继&lt;a href=&quot;http://blog.csdn.net/xiong_it/article/details/53467684&quot;&gt;《设计模
      
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：OOP设计6大原则</title>
    <link href="http://blog.michaelx.tech/2017-01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%9AOOP%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.michaelx.tech/2017-01/设计模式系列：OOP设计6大原则/</id>
    <published>2017-01-13T02:39:20.000Z</published>
    <updated>2022-12-02T03:10:42.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限，你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？<br>Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？</p><pre><code>本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。</code></pre><h2 id="Open-Close-Principle"><a href="#Open-Close-Principle" class="headerlink" title="Open Close Principle"></a>Open Close Principle</h2><blockquote><p>OCP原则（开闭原则）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p></blockquote><p>wtf???太抽象了！！！在笔者的理解中，OCP是6大原则的最高纲领，所以才如此抽象，晦涩难懂。用面向对象的语言来讲，OCP是一个最抽象的接口，而其余的5大原则只是OCP的子类接口，他们一起定义了OOP世界的开发标准，常用的23中设计模式更是只能算作这6大原则的实现抽象类，咱们开发的代码实践才是真正的具体子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface OCP &#123;</span><br><span class="line">void openExtention();</span><br><span class="line">void closeModifiability();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q:What is OCP？<br>A:OCP是啥咧？它告诉我们，咱们编写的代码应该面向扩展开放，而尽量不要通过修改现有代码来拥抱需求变更。这里，代码可以指的是一个功能模块，类，或者方法。<br>Q:Why do we need to follow this principle？<br>A:我们为什么要遵循OCP原则呢？地球人都知道代码后期需求变更的痛苦，如果不利用扩展来适应变更，那迎来的将是代码被修改的千疮百孔。<br>Q:How do we practice this principle？<br>A:我们如何实践这条原则？能用抽象类的别用具体类，能用接口的别用抽象类。总之一句：尽量面向接口编程。这里之所以说“尽量”是因为凡事都有度，别让你来个hello world你还给整个接口再实现。</p><p><strong>talk is cheap，show your the code.</strong></p><pre><code> 需求：老王开车去东北。</code></pre><p>简单，开撸。</p><p>老王来了，大家藏好自己媳妇儿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Laowang &#123;</span><br><span class="line">private Car car;</span><br><span class="line">private DongBei dongbei;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">getter() &amp; setter()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void drive() &#123;</span><br><span class="line">car.goto(dongbei);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要车就给你一辆咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">public void goto(DongBei dongbei) &#123;</span><br><span class="line">System.out.println(“要去东北咯，啦啦啦”);</span><br><span class="line">// 模拟开车旅途消耗时间。10s就到东北了，开的可够快的啊！司机之前是开飞机的吗？</span><br><span class="line">Thread.getCurrentThread().sleep(10 * 1000);</span><br><span class="line">System.out.println(“目的地东北到了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>东北到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DongBei &#123;</span><br><span class="line">private String address = &quot;东北那旮沓儿&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老司机要发车了，赶紧打卡上车。滴，学生卡，咳咳咳，拿错卡了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Car car = new Car();</span><br><span class="line">Laowang wang = new Laowang();</span><br><span class="line">wang.setCar(car);</span><br><span class="line">DongBei dongbei = new DongBei();</span><br><span class="line">wang.setDongbei(dongbei);</span><br><span class="line">wang.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Perfect，完美！<br>现在需求变了，老王实现了2017年定下的小目标，挣了1个亿，买了架私人飞机，他不想开车去东北了，太low，他要开飞机去东北。</p><pre><code>需求2：老王开飞机去东北</code></pre><p>简单，给老王加个属性，加几个方法就实现了嘛？代码就不撸了。<br>OK，又是一次完美变化！？<br>需求又变了，老张和老王是穿一条裤裆长大的发小，老张看老王这都开上飞机了，他的车是不是可以借来开一开？</p><pre><code>需求3：老张开车去东北</code></pre><p>这，这，这，简单，重新撸一遍老王在需求1的代码就行了，不就改个名的事吗？<br>来来来，需求又变了，老张有急事去东北，老王就把飞机也借给老张用了。</p><pre><code>需求4：老张开飞机去东北</code></pre><p>这，这，这，这，这，这，简单，把老王在需求2的代码重撸一遍就是了。<br>来来来，需求又变了，老王这回不去东北了，他想开飞机去广东那儿去探望下老丈人，顺便兜兜风。</p><pre><code>需求5：老王开飞机去广东需求6：老张开车去广东需求7：老王要开飞机去美国需求8：小王要开车去西藏需求...</code></pre><p>这，这，这，这这这，R&amp;D小哥一口老血喷在屏幕上，卒，享年25岁。</p><p>在这里，笔者建议，将人物，交通工具，目的地抽象化，接口化，就可以适应需求的频繁变更了。</p><p>上类图<br><img src="http://img.blog.csdn.net/20170111203335703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" data-srcset="http://img.blog.csdn.net/20170111203335703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="OCP demo类图"><br>客户端代码作如下调整：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 想用地上开的交通工具出行，好，那就new个车给你开</span><br><span class="line">ITransportation car = new Car();</span><br><span class="line">// 这次是老王要出门</span><br><span class="line">Person wang = new Laowang();</span><br><span class="line">// 老王选择开车出行</span><br><span class="line">wang.setTransportation(car);</span><br><span class="line">// 老王目的地是东北</span><br><span class="line">AbsDestination dongbei = new DongBei();</span><br><span class="line">dongbei.setAddressName(&quot;东北&quot;);</span><br><span class="line">wang.setDestination(dongbei);</span><br><span class="line">// 老司机开着车就出发了</span><br><span class="line">wang.startOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老王的代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Laowang extends Person&#123;</span><br><span class="line">...</span><br><span class="line">public void startOff() &#123;</span><br><span class="line">this.transportation.transport();</span><br><span class="line">System.out.println(&quot;出发咯&quot;);</span><br><span class="line">//thread.sleep();</span><br><span class="line">System.out.println(&quot;目的地&quot; + this.destination.getAddressName() +&quot;到了.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><pre><code>出发咯目的地东北到了.</code></pre><p>现在，假如要做如上一些需求变更，在需求的变更过程中，客户端的代码变化是不是小多了呢？</p><blockquote><p> 注意：开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层次模块的变化，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。<br>在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，放置变化风险的扩散<br>—秦小波《设计模式之禅》</p></blockquote><h2 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h2><blockquote><p> SRP原则（职责单一原则）:应该有且只有一个原因引起类的变更。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SRP extends OCP &#123;</span><br><span class="line">void onlyDoOneThing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通俗点来讲，一个类，一个方法只应该做一件事情。<br>举2个栗子：<br>1.当一个类A有R1，R2两个职责时，当R1的职责发生变更时，你需要修改类A，当R2发生变更时，你又需要修改类A，这时，已经有2个原因可能会引起类的变化了，类A就已经职责不单一了，就需要职责拆分，比如拆分成类A1，A2：A1类负责R1职责，A2类负责R2职责了。<br>2.再比如有一个方法M，它即负责计算和打印两个职责</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void M(int a, int b) &#123;</span><br><span class="line">int c = 0;</span><br><span class="line">c = a + b;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;打印的是 = &quot; + c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一天，你想要修改下计算规则，改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c=a+b+1;</span><br></pre></td></tr></table></figure><p>此时，你修改了方法M。<br>又一天，你想修改下打印规则，改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;打印的是 = &quot; + （c+1）); </span><br></pre></td></tr></table></figure><p>你又修改了方法M，此时，超过了2个原因让你去修改它，所以这个方法应该拆分为待返回值得计算calc方法和打印print两个方法。<br>似的每个方法都只做一件事情。</p><p>那它是如何体现扩展性的呢？<br>拿一个Android中最常见的ImageLoader的设计来举例子，ImageLoader主要需要实现2个功能，下载图片，缓存图片。<br>假如，我们把所有的功能全部放在一个ImageLoader类中，假设下载要改方式呢？缓存要改策略呢？你通通要改ImageLoader，你如何保证修改某个功能的过程中另一个功能依旧完好，没被污染？拆分职责，使用ImageCache接口及其子类实现进行缓存，和ImageLoader建立关联，职责单一了，你再在每个单一的职责类里面去修改相关代码，这样其他功能代码被污染的概率大大降低。</p><p>当然，这里只是随意举的例子，划分单一职责这个度很难把握，每个人都需要根据自身情况和项目情况来进行判断。</p><h2 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h2><blockquote><p>OCP原则(里氏替换原则)：所有引用基类的地方必须能透明地使用其子类的对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LSP extends OCP &#123;</span><br><span class="line">void liskovSubstitutionPrinciple();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通俗点讲：只要父类能出现的地方子类就可以出现，而且替换为子类也不产生任何异常错误，反之则不然。这主要体现在，我们经常使用抽象类&#x2F;基类做为方法参数，具体使用哪个子类作为参数传入进去，由调用者决定。</p><p>这条原则包含以下几个方面：</p><ul><li>子类必须完全实现父类的方法</li><li>子类可以有自己的个性外观（属性）和行为（方法）</li><li>覆盖或者实现父类方法时，参数可以被放大。即父类的某个方法参数为HashMap时，子类参数可以是HashMap，也可以是Map或者更大</li><li>覆盖或者实现父类的方法时，返回结果可以被缩小。即父类的某个方法返回类型是Map，子类可以是Map，也可以是HashMap或者更小。</li></ul><h2 id="Dependence-Inversion-Principle"><a href="#Dependence-Inversion-Principle" class="headerlink" title="Dependence Inversion Principle"></a>Dependence Inversion Principle</h2><blockquote><p>DIP原则（依赖倒置原则）：高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节而，具体细节应该依赖于抽象</p></blockquote><p>底层模块：不可分割的原子逻辑就是低层模块<br>高层模块：低层模块的组装合成后就是高层模块</p><p>抽象：Java中体现为基类，抽象类，接口，而不单指抽象类<br>细节：体现为子类，实现类</p><p>通俗点讲，该原则包含以下几点要素：</p><ul><li>模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系</li><li>接口或者抽象类不依赖于实现类，否则就失去了抽象的意义</li><li>实现类依赖于接口或者抽象类</li></ul><p>总结起来，一句话：”<strong>面向接口编程</strong>“。</p><h2 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface-Segregation Principle"></a>Interface-Segregation Principle</h2><blockquote><p>ISP原则（接口隔离原则）:客户端不应该依赖它不需要的接口；类间的依赖应该建立在最小的接口上</p></blockquote><p>通俗点讲：使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。</p><p>这里我想举个例子就是Android中的事件处理Listener设计，大家都知道，我们想给button添加点击事件时，可以使用如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(clickListener);</span><br></pre></td></tr></table></figure><p>想给它添加长按事件时，可以使用如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnLongClickListener(longClickListener);</span><br></pre></td></tr></table></figure><p>还有其他比如OnTouchListener等等等事件接口，它为什么不直接提供一个通用的接口IListener呢？然后回调所有的事件给调用者处理，而要提供这么多独立的接口，这就是遵循了ISP原则的结果，每个接口最小化了，Activity&#x2F;button作为调用者，我可以选择性的去处理我想处理的事件，不关心的事件Listener我就不去处理，依赖。</p><h2 id="Low-of-Demeter"><a href="#Low-of-Demeter" class="headerlink" title="Low of Demeter"></a>Low of Demeter</h2><blockquote><p>LoD法则（迪米特法则）：又称最少知识原则（Least Knowledge Principle， LKP），一个对象应该对其他对象有最少的了解。</p></blockquote><p>通俗点讲：一个类应该对自己需要耦合或者调用的类知道越少越好，被耦合或者调用的类内部和我没有关系，我不需要的东西你就别public了吧。</p><p>迪米特法则包含以下几点要素：</p><ul><li>只和朋友类交流：只耦合该耦合的类</li><li>朋友间也是有距离的：减少不该public的方法，向外提供一个简洁的访问</li><li>自家的方法就自己创建：只要该方法不会增加内部的负担，也不会增加类间耦合</li></ul><h2 id="感谢和参考"><a href="#感谢和参考" class="headerlink" title="感谢和参考"></a>感谢和参考</h2><h2 id="秦小波：《设计模式之禅》Mr-simple：《Android-源码设计模式解析与实战》java-my-life-http-www-cnblogs-com-java-my-life-……后话"><a href="#秦小波：《设计模式之禅》Mr-simple：《Android-源码设计模式解析与实战》java-my-life-http-www-cnblogs-com-java-my-life-……后话" class="headerlink" title="秦小波：《设计模式之禅》Mr.simple：《Android 源码设计模式解析与实战》java-my-life:http://www.cnblogs.com/java-my-life/……后话"></a>秦小波：《设计模式之禅》<br>Mr.simple：《Android 源码设计模式解析与实战》<br>java-my-life:<a href="http://www.cnblogs.com/java-my-life/">http://www.cnblogs.com/java-my-life/</a><br>…<br>…<br>后话</h2><p>规则只是规则，大家不应该死守规则，应该持辩证的态度去看待这6大原则，才能更好地达到实践应用的目的。<br>感谢以上作者和博客的规范化引导以及诸多博主的博客才渐渐让我懂得实践设计模式与应用架构。笔者将会未来陆续更新《设计模式系列》in Android博客，后续博客中，均参考了以上书籍和博客。欢迎各位朋友评论区点赞拍砖交流。</p>]]></content>
    
    <summary type="html">
    
      相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限,你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="6大原则" scheme="http://blog.michaelx.tech/tags/6%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="OOP" scheme="http://blog.michaelx.tech/tags/OOP/"/>
    
  </entry>
  
</feed>
