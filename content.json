{"meta":{"title":"MichaelX's Blog","subtitle":"MichaelX的开发博客","description":"求索技术之道，追寻代码之美","author":"MichaelX","url":"http://blog.michaelx.tech","root":"/"},"pages":[{"title":"","date":"2022-12-02T03:10:42.353Z","updated":"2022-12-02T03:10:42.353Z","comments":true,"path":"404.html","permalink":"http://blog.michaelx.tech/404.html","excerpt":"","text":"MichaelX's Blog-404页面"},{"title":"","date":"2017-01-12T11:57:43.000Z","updated":"2022-12-02T03:10:42.356Z","comments":true,"path":"about/index.html","permalink":"http://blog.michaelx.tech/about/index.html","excerpt":"","text":"国内某知名互联网公司不知名程序员，主要从事Android领域Application开发。轻微代码洁癖患者，google粉，喜欢编程和分享，仅此。 人生格言：求索技术之道，追寻代码之美。共勉！"},{"title":"分类","date":"2017-01-12T12:24:55.000Z","updated":"2022-12-02T03:10:42.356Z","comments":false,"path":"categories/index.html","permalink":"http://blog.michaelx.tech/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-12T12:24:39.000Z","updated":"2022-12-02T03:10:42.357Z","comments":false,"path":"tags/index.html","permalink":"http://blog.michaelx.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Design Patterns in Android：装饰模式","slug":"Design-Patterns-in-Android：装饰模式","date":"2018-06-13T09:12:00.000Z","updated":"2022-12-06T12:13:54.242Z","comments":true,"path":"2018-06/Design-Patterns-in-Android：装饰模式/","link":"","permalink":"http://blog.michaelx.tech/2018-06/Design-Patterns-in-Android%EF%BC%9A%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","excerpt":"装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。","text":"装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。前言装饰模式是干嘛的呢？它在项目中有哪些用途呢？装饰模式在Android源码中有哪些应用呢？本文将和读者朋友一起分享探讨装饰者模式在Android中的应用和实践。 本文原创作者MichaelX。 CSDN博客：https://blog.csdn.net/xiong_it 掘金主页：https://juejin.im/user/56efe6461ea493005565dafd 知乎专栏：https://zhuanlan.zhihu.com/c_144117654 个人博客：http://blog.michaelx.tech 转载请注明出处。 装饰模式定义 装饰者模式：也叫wrapper模式。动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式相比生成子类更加灵活，提供了有别于继承的另一种选择。 装饰模式的UML类图有四个角色需要说明： Component抽象构件Component是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，如上面的成绩单。 注意：在装饰模式中，必然有一个最基本、最核心、最原始的接口或抽象类充当Component抽象构件。 ConcreteComponent 具体构件ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是它。 Decorator装饰角色一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，在它的属性里必然有一个private变量指向Component抽象构件。 具体装饰角色ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类，你要把你最核心的、最原始的、最基本的东西装饰成其他东西。 装饰模式示例代码1234public abstract class Component &#123; //抽象的方法 public abstract void operate();&#125; 1234567public class ConcreteComponent extends Component &#123; //具体实现 @Override public void operate() &#123; System.out.println(&quot;do Something&quot;); &#125;&#125; 123456789101112public abstract class Decorator extends Component &#123; private Component component = null; //通过构造函数传递被修饰者 public Decorator(Component _component)&#123; this.component = _component; &#125; //委托给被修饰者执行 @Override public void operate() &#123; this.component.operate(); &#125;&#125; 123456789101112131415public class ConcreteDecorator1 extends Decorator &#123; //定义被修饰者 public ConcreteDecorator1(Component _component)&#123; super(_component); &#125; //定义自己的修饰方法 private void method1()&#123; System.out.println(&quot;method1 修饰&quot;); &#125; //重写父类的Operation方法 public void operate()&#123; this.method1(); super.operate(); &#125;&#125; 123456789101112131415public class ConcreteDecorator2 extends Decorator &#123; //定义被修饰者 public ConcreteDecorator2(Component _component)&#123; super(_component); &#125; //定义自己的修饰方法 private void method2()&#123; System.out.println(&quot;method2修饰&quot;); &#125; //重写父类的Operation方法 public void operate()&#123; super.operate(); this.method2(); &#125;&#125; 使用场景类 1234567891011public class Client &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); //第一次修饰 component = new ConcreteDecorator1(component); //第二次修饰 component = new ConcreteDecorator2(component); //修饰后运行 component.operate(); &#125;&#125; Android源码中的装饰模式案例一Context是Android中一个几乎无处不在的角色，ContextWrapper&#x2F;ContextThemeWrapper就在继承过程中承担了ContextImpl的装饰者角色。ContextThemeWrapper部分代码为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ContextThemeWrapper extends ContextWrapper &#123; private int mThemeResource; private Resources.Theme mTheme; private LayoutInflater mInflater; private Configuration mOverrideConfiguration; private Resources mResources; @Override public AssetManager getAssets() &#123; // Ensure we&#x27;re returning assets with the correct configuration. return getResourcesInternal().getAssets(); &#125; @Override public Resources getResources() &#123; return getResourcesInternal(); &#125; private Resources getResourcesInternal() &#123; if (mResources == null) &#123; if (mOverrideConfiguration == null) &#123; mResources = super.getResources(); &#125; else &#123; final Context resContext = createConfigurationContext(mOverrideConfiguration); mResources = resContext.getResources(); &#125; &#125; return mResources; &#125; @Override public Resources.Theme getTheme() &#123; if (mTheme != null) &#123; return mTheme; &#125; mThemeResource = Resources.selectDefaultTheme(mThemeResource, getApplicationInfo().targetSdkVersion); initializeTheme(); return mTheme; &#125; @Override public Object getSystemService(String name) &#123; if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123; if (mInflater == null) &#123; mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this); &#125; return mInflater; &#125; return getBaseContext().getSystemService(name); &#125; protected void onApplyThemeResource(Resources.Theme theme, int resId, boolean first) &#123; theme.applyStyle(resId, true); &#125; private void initializeTheme() &#123; final boolean first = mTheme == null; if (first) &#123; mTheme = getResources().newTheme(); final Resources.Theme theme = getBaseContext().getTheme(); if (theme != null) &#123; mTheme.setTo(theme); &#125; &#125; onApplyThemeResource(mTheme, mThemeResource, first); &#125;&#125; 案例二还有一个比较典型的例子是RecyclerView通过RecyclerView.ItemDecorator来扩展样式。不过这个是一个变种的装饰者，这个实践比较另类的地方在于：我们通常是在装饰者的的执行方法中扩展被代理对象的行为，而RecyclerView+ItemDecorator的实践则恰恰相反，ItemDecorator反倒成了被代理对象，RecyclerView成了装饰者。 Android开发中的装饰模式实践说实话，笔者自己也没有实践过装饰模式，但是有一个场景需求应该是可以应用装饰模式的。比如一个直播场景，点击礼物时需要礼物飞出来，双击有一个爱心❤️飘出来，那么礼物和爱心就可以看成是直播画面的装饰者，类关系如下：GirlView：主播画面GirlDecorator：主播画面装饰者GiftView：礼物效果LoveView：爱心效果 总结特点：装饰模式其实就是在代理某个对象过程中，给特定的代理行为前后加上不同的装饰行为，比如文中的ContextThemeWrapper就在代理ContextImpl的getSystemService这个行为过程中，加上了返回LayoutInflater这个装饰行为。因此，我们也可以认为装饰模式其实是一种特殊的代理模式 装饰模式的优缺点优点： 装饰类和被装饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道Decorator类，Decorator类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构件。 装饰模式是继承关系的一个替代方案。我们看装饰类Decorator，不管装饰多少层，返回的对象还是Component，实现的还是is-a的关系。 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。 缺点： 装饰太多层时会增加系统复杂度，有时出现问题可能无法快速定位。 当某个对象的行为需要加强，并且可能有多种加强的需求时，那么装饰模式有可能就能排上用场了。 好了，今天的《设计模式Android篇：装饰模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"装饰模式","slug":"装饰模式","permalink":"http://blog.michaelx.tech/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"name":"Decorator","slug":"Decorator","permalink":"http://blog.michaelx.tech/tags/Decorator/"}]},{"title":"Design Patterns in Android：责任链模式","slug":"Design-Patterns-in-Android：责任链模式","date":"2018-05-14T09:55:55.000Z","updated":"2022-12-06T12:13:54.242Z","comments":true,"path":"2018-05/Design-Patterns-in-Android：责任链模式/","link":"","permalink":"http://blog.michaelx.tech/2018-05/Design-Patterns-in-Android%EF%BC%9A%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/","excerpt":"今天给大家分享的是《设计模式Android篇:责任链模式》。今天将通过Android源码和Android开发案例跟大家讲解什么是责任链模式。","text":"今天给大家分享的是《设计模式Android篇:责任链模式》。今天将通过Android源码和Android开发案例跟大家讲解什么是责任链模式。 前言非常抱歉，本系列博客长达半年没更新了，今日偶得灵感，更新一波《设计模式Android篇:责任链模式》。点击此处查看《Design Patterns in Android》系列其他文章。 本文原创作者MichaelX。CSDN博客：http://blog.csdn.net/xiong_it掘金主页：https://juejin.im/user/56efe6461ea493005565dafd知乎专栏：https://zhuanlan.zhihu.com/c_144117654个人博客：http://blog.michaelx.tech转载请注明出处。 责任链模式定义 职责链(Chain-of-responsibility pattern):它是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 责任链模式的UML类图责任链模式各角色分工： Client:发出请求的高层代码。 Handler:定义一个处理请求的接口。一般会定义一个处理请求的抽象方法（handleRequest()），以及一个set方法(setSuccessor)来指定下后续处理者。 ConcreteHandler:具体的请求处理者，收到请求后可以自己处理，也可以将请求传递给后续处理者。 责任链示例代码这里举个栗子：老王在中介所要买个二手房，他提出价格过高，希望得到更多的优惠，比如88折，中介经纪人小明收到请求。以下是处理流程。 Client发起购房请求 12345678910111213public class Client &#123; public static void main(String[] args) &#123; HouseBuyer laowang = new HouseBuyer(&quot;老王&quot;); laowang.buyHouse(&quot;88折卖不卖？&quot;); &#125;&#125;public class HouseBuyer &#123; public void buyHouse(int accountOff) &#123; AbsAgency xiaoming = new Staff(&quot;底层员工小明&quot;); xiaoming.handle(accountOff); &#125;&#125; 抽象处理者Handler 1234567891011121314public abstract class AbsAgency &#123; protected AbsAgency mAgency; public void setNextHandler(AbsAgency agency) &#123; this.mAgency = agency; &#125; // 处理折扣 public abstract void handle(int accountOff); public AbsAgency geNextHandler() &#123; return mAgency; &#125;&#125; 具体处理者：处理购房请求 12345678910111213141516171819202122232425262728public class Staff extends AbsAgency &#123; public abstract void handle(int accountOff) &#123; // 如果折扣低于80折，不出售； // 如果90折以上，一线员工自行处理; // 低于90折，需要汇报经理处理 if (accountOff &lt;= 80) &#123; System.out.println(&quot;价格太低，要吃土咯。。。&quot;); &#125; else if (accountOff &gt; 90 &amp;&amp; accountOff &lt;= 100) &#123; System.out.println(&quot;价格合适，卖给你了。&quot;); &#125; else &#123; setNextHandler(new Manager(&quot;上级经理&quot;)); getNextHandler().handle(accountOff); &#125; &#125;&#125;public class Manager extends AbsAgency &#123; public abstract void handle(int accountOff) &#123; // 如果折扣低于80折，不出售； // 根据人品决定是否接受购房请求 if (accountOff &lt;= 80) &#123; System.out.println(&quot;价格太低，要吃土咯。。。&quot;); &#125; else &#123; System.out.println(&quot;老王人品还行，成交。&quot;); &#125; &#125; 最终老王的购房请求在经理这个级别得到了处理，但是老王才不关心谁解决的，只要能低价买到这个房子就行了。 Android源码中责任链模式责任链模式思想在Android源码中的体现莫过于：触摸事件的处理和分发了。每当用户接触屏幕时，Android都会将其打包成一个MotionEvent对象从ViewTree自顶而下的分发处理。代码过多，这里只用一张图表示其思路：其方向为：Activity---&gt;ViewGroup---&gt;View具体源码可参考郭神的《Android事件分发机制完全解析，带你从源码的角度彻底理解(上)》，阅读源码，我们可以发现dispatchTouchEvent有点类似上面责任链实例代码中的handle()方法，自己能处理就处理，处理不了就向下一级分发处理。 Android开发中的责任链模式实践举个例子，我们的图片需要设计三级缓存，那么它是怎么取缓存的呢？ 12AbsCacheManager bmpCache = new MemoryCache();Bitmap bmp = bmpCache.getCache(cacheKey); 先定义一个缓存抽象类 1234567891011121314public abstract class AbsCacheManager &#123; protected AbsCacheManager mCache; // 获取Bitmap public abstract Bitmap getCache(String cacheKey); public void setNextHandler(AbsCacheManager manager) &#123; mCache = manager; &#125; public AbsCacheManager getNextHandler() &#123; return mCache; &#125;&#125; 下面是具体实施者：内存缓存，磁盘缓存，网络获取 123456789101112131415161718192021222324252627282930313233public class MemoryCache extends AbsCacheManager &#123; public Bitmap getCache(String cacheKey) &#123; Bitmap bmp = getCacheFromMemory(cacheKey); // 如果内存缓存为空，则将请求传递给下一位：磁盘缓存来处理 if (bmp == null) &#123; setNextHandler(new DiskCache()); bmp = getNextHandler().getCache(cacheKey); &#125; return bmp; &#125;&#125;public class DiskCache extends AbsCacheManager &#123; public Bitmap getCache(String cacheKey) &#123; Bitmap bmp = getCacheFromDisk(cacheKey); // 如果磁盘缓存为空，则将请求传递给下一位：网络图片下载来处理 if (bmp == null) &#123; setNextHandler(new NetworkFetchManager()); bmp = getNextHandler().getCache(cacheKey); &#125; return bmp; &#125;&#125;public class NetworkFetchManager extends AbsCacheManager &#123; public Bitmap getCache(String cacheKey) &#123; Bitmap bmp = getCacheFromNetWork(cacheKey); return bmp; &#125;&#125; 一条责任链跃然纸上：内存—&gt;磁盘-&gt;网络。 当然，以上没有考虑线程切换问题，实际操作是需要考虑耗时操作在子线程执行的。 总结其实责任链模式就是在某种场景下：有一个请求需要处理，但是最终处理者又不确定的时候采用的一种模式。但是其处理者对于客户端是透明的，无需知道谁将处理这个请求，只需要抛出请求，拿到结果即可。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"责任链模式","slug":"责任链模式","permalink":"http://blog.michaelx.tech/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"name":"Chain-of-responsibility","slug":"Chain-of-responsibility","permalink":"http://blog.michaelx.tech/tags/Chain-of-responsibility/"}]},{"title":"Android笔记：Bitmap.Config与内存占用的关系","slug":"Android笔记：Bitmap.Config与内存占用的关","date":"2017-12-04T11:12:18.000Z","updated":"2022-12-06T12:13:54.241Z","comments":true,"path":"2017-12/Android笔记：Bitmap.Config与内存占用的关/","link":"","permalink":"http://blog.michaelx.tech/2017-12/Android%E7%AC%94%E8%AE%B0%EF%BC%9ABitmap.Config%E4%B8%8E%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%9A%84%E5%85%B3/","excerpt":"Bitmap内存占用与Config关系笔记","text":"Bitmap内存占用与Config关系笔记关于内存占用Q:请问Bitmap的内存占用如何计算？A:int momery &#x3D; higthPixel * widthPixel * config因子; 什么是config因子？接着看。 Config因子123456enum Bitmap.Config &#123; ALPHA_8, RGB_565, RGB_444, // 3.0及以上已废弃，使用RGB_8888代替 ARGB_8888&#125; ALPHA_8（基本不用）:每个像素使用一个独立的alpha通道存储，该通道占用8bit，即：每个像素占用1byte = 8bit / 8内存，如果bitmap使用这种config编码，以上config因子为1；注意：此属性会导致RGB通道信息丢失，只剩下透明度，所以基本不会用到 RGB_565:只编码RGB通道信息，没有透明alpha通道信息，Red红色通道信息占用5位内存，Green绿色通道信息占用6位内存，Blue蓝色通道信息占用5位内存。每个像素占用2 byte= (5bit + 6bit + 5bit) / 8 内存，支持2^16 &#x3D; 65535种颜色。质量较好，此时config因子为2； ARGB_8888:每个通道（Alpha+RGB）都各占用8位内存，支持2^32 &#x3D; 1600w种颜色，质量最好，每个像素占用4 byte = 8bit * 4 / 8内存，此时config因子为4。 RGB_565比ARGB_8888节省内存相信很多同学都知道，但是为什么RGB_565更节省内存？Bitmap每个像素的内存占用是怎么来的？希望本文能解决一些同学的疑惑。因为RGB_565牺牲了alpha通道，不支持透明度，并且RGB每个通道信息较ARGB_888更少。 不同Config加载效果图 原颜色值：#9966AAFF 使用ALPHA_8加载丢失了RGB信息 使用RGB_565加载丢失了alpha通道透明度 使用ARGB_8888可正常加载 本文作者MichaelX，个人博客：http://blog.michaelx.tech 本文遵从CC协议，转载请注明出处。 结论当加载一张1080 * 1920px的图片时，使用以上config加载的内存占用情况分别为： ALPHA_8（基本不用）:1080 * 1920 byte &#x3D; 2025Kb &#x3D; 2Mb RGB_565:1080 * 1920 * 2 byte &#x3D; 4050Kb &#x3D; 4Mb ARGB_8888:1080 * 1920 * 4 byte &#x3D; 8100Kb &#x3D; 8Mb 可以酌情选择合适的config进行加载，但是最好全局只使用一个config，否则易导致个别图片信息丢失或者加载错误。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"Bitmap.Config","slug":"Bitmap-Config","permalink":"http://blog.michaelx.tech/tags/Bitmap-Config/"}]},{"title":"Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程","slug":"Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程","date":"2017-11-30T06:10:18.000Z","updated":"2022-12-06T12:13:54.242Z","comments":true,"path":"2017-11/Hexo遇上Travis-CI：可能是最通俗易懂的自动发布博客图文教程/","link":"","permalink":"http://blog.michaelx.tech/2017-11/Hexo%E9%81%87%E4%B8%8ATravis-CI%EF%BC%9A%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/","excerpt":"今天笔者就来介绍下利用travis-ci这个持续集成平台简化发布流程.","text":"今天笔者就来介绍下利用travis-ci这个持续集成平台简化发布流程. 相信很多同学都有自己的博客，如果没有，可以参看《Hexo建站：部署到github》，利用Hexo和github pages服务搭建一个美观便捷的博客，Hexo可以将你编写的md文档解析渲染成html网页，最后通过git推送到github即可形成一个网站。 Hexo发布博客流程 搭建hexo环境（一系列软件安装，配置） hexo new post “文章名称” 编写md文档 hexo clean hexo generate hexo deploy 以上第一步一般只在第一次搭建的时候需要进行，后续只要执行2~6步即可。但是存在一些情况，假如你需要在不同的电脑上发布博客呢？假如你重装了系统呢？是不是需要重新来一次？要知道最繁琐的步骤就是第一步，这里面可以分出很多步来做，看过上面那篇博客或者自己正在使用hexo+gh手动发布博客的同学都知道多痛苦。 今天笔者就来介绍下利用travis-ci这个持续集成平台简化发布流程，简化后流程: 编写md文档 git push 利用travis大大提高了效率！是不是很诱人？ Travis-CI简介Travis CI 是开源持续集成构建项目，用来构建托管在GitHub上的代码。它提供了多种编程语言的支持，包括JavaScript，Java，Scala，Ruby，PHP，Haskell和Erlang在内的多种语言。 当我们每次进行git push等动作时，Travis CI 会自动检测我们的提交，然后根据配置文件.travis.yml帮我们自动生成、部署静态网页。 事先预备推送hexo博客源码到github cd进入自己的本地hexo博客文件夹，就是你要发布博客时进入的那个文件夹。 将自己本地所有hexo博客源码文件push到github。推送教程：《如何提交代码到Github》 注意：不是hexo deploy更新博客repo！而是直接把本地博客托管到github。 笔者直接把本地hexo博客源码托管到了xiong-it.github.io的hexo分支，博客网站则在默认的master分支上。不想采取分支管理的话，你也可以把本地hexo博客托管到独立仓库，但是在配置travis同步时会有所不同。本文采取分支管理方式。 配置github token那既然需要使用travis自动化更新你的博客，travis自然需要读写你的github上的repo。github提供了token机制来供外部访问你的仓库。 进入https://github.com/settings/tokens，生成一个供travis读写你的github用的token，至于token的权限，笔者直接全选了，但是不建议这样做，风险比较大，token注意保密，待会会用到。 配置Travis-CI使用github账号登陆travis，如果没有github账号的同学，可以参考《如何提交代码到Github》注册一个自己的github账号。 在travis进入仓库同步管理进入https://travis-ci.org/profile，打开刚才托管的hexo博客源码仓库同步开关，不一定是博客网站repo。由于笔者直接把本地hexo博客源码托管到了xiong-it.github.io的hexo分支，所以也就是打开网站repo。如果你不是采取的分支管理，而是将hexo博客源码托管道独立repo，打开对应的github repo开关即可。如图： travis设置点击上图中红色圆圈，进入设置页，设置自动化编译时机，自动化编译过程中需要用到的变量。 以上设置的含义是： 只在.travis.yml文件存在时编译，必选！ 当仓库&#x2F;分支发生更新时编译，也就是push后进行编译的意思，一般会需要选择，方便自动化构建。 加了GH_TOEKN等变量，value值为刚才预备工作中准备的token字符串 编写.travis.yml文件.travis.yml是travis平台进行自动化构建的配置文件，travis会根据配置文件生成一个shell自动化脚本。 进入hexo博客源码本地repo 123cd hexotouch .travis.ymlvim .travis.yml .travis.yml示例如下： 1234567891011121314151617181920212223242526272829303132333435363738# 指定语言环境language: node_js# 指定需要sudo权限sudo: required# 指定node_js版本node_js: - 7.9.0# 指定缓存模块，可选。缓存可加快编译速度。cache: directories: - node_modules # 指定博客源码分支，因人而异。hexo博客源码托管在独立repo则不用设置此项branches: only: - hexo before_install: - npm install -g hexo-cli# Start: Build Lifecycleinstall: - npm install - npm install hexo-deployer-git --save # 执行清缓存，生成网页操作script: - hexo clean - hexo generate # 设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署after_script: - git config user.name &quot;yourName&quot; - git config user.email &quot;yourEmail&quot; # 替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！ - sed -i &quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot; ./_config.yml - hexo deploy# End: Build LifeCycle 修改下_config.yml文件的deploy节点： 12345# 修改前deploy: - type: git repo: git@github.com:xiong-it/xiong-it.github.io.git branch: master 123456# 修改后deploy:- type: git # 下方的gh_token会被.travis.yml中sed命令替换 repo: https://gh_token@github.com/xiong-it/xiong-it.github.io.git branch: master yml示例传送门 最后将两个yml文件push更新到hexo博客源码branch或者独立repo，就会在travis后台成功看到第一次构建了。 欢迎访问我的个人hexo博客：http://xiong-it.github.io 大功告成以后每次更新博客，只需要编写md文件，放入hexo&#x2F;source&#x2F;_post&#x2F;文件夹下，git add，commit，push后，push操作也可以直接使用刚才申请的token，而无需在不同电脑上配置ssh共密钥。 1git push https://&lt;your_token&gt;@github.com/xiong-it/xiong-it.github.io.git hexo:hexo travis就会读取hexo博客源码分支下的.travis.yml文件，自动帮我们生成并部署网站了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://blog.michaelx.tech/categories/hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.michaelx.tech/tags/Hexo/"},{"name":"travis","slug":"travis","permalink":"http://blog.michaelx.tech/tags/travis/"}]},{"title":"Android：使用LoadingLayout来展示加载数据时不同状态","slug":"Android：使用LoadingLayout来展示加载数据时不同状态","date":"2017-11-21T05:11:00.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-11/Android：使用LoadingLayout来展示加载数据时不同状态/","link":"","permalink":"http://blog.michaelx.tech/2017-11/Android%EF%BC%9A%E4%BD%BF%E7%94%A8LoadingLayout%E6%9D%A5%E5%B1%95%E7%A4%BA%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E6%97%B6%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81/","excerpt":"LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。","text":"LoadingLayout:应用于Android中的一个加载数据不同状态的类库（自定义控件）。LoadingLayout简介 应用于Android中的一个加载数据不同状态的类库（自定义控件）。 https://github.com/xiong-it/LoadingLayout Compile打开你的app module中的build.gradle,添加依赖：1compile &#x27;tech.michaelx.loadinglibrary:loadinglibrary:1.0.1&#x27;Sample 在layout的xml中使用如下： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;tech.michaelx.loadinglibrary.LoadingLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/loading_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:contentDescription=&quot;loadingBackground可以是drawable或者颜色&quot; android:padding=&quot;10dp&quot; app:emptyView=&quot;@layout/empty_layout&quot; app:errorView=&quot;@layout/failure_layout&quot; app:loadingAnimator=&quot;@animator/loading&quot; app:loadingBackground=&quot;#1296db&quot; app:loadingView=&quot;@layout/loading_layout&quot; app:retryLoadAlways=&quot;true&quot; app:showLoadingDebug=&quot;true&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;本页面使用属性自定义loading各种状态&quot; /&gt;&lt;/tech.michaelx.loadinglibrary.LoadingLayout&gt; 常用自定义属性 app:loadingView=&quot;@layout/loading_layout&quot; :指定加载时的展示布局，可以为空，为空时使用系统默认ProgressBarapp:loadingAnimator=&quot;@animator/loading&quot;:只用上述属性制定时，该属性方可生效，作用于加载布局的动画app:loadingBackground=&quot;#1296db&quot;:指定加载过程中页面背景，可以是颜色或者drawable，默认为adnroid:color&#x2F;whiteapp:emptyView=&quot;@layout/empty_layout&quot;:指定了数据为空时的展示布局，可以为空，有默认布局，详细可看下方演示gif图app:errorView=&quot;@layout/failure_layout&quot;:指定加载失败时的展示布局，可以为空，有默认布局，详细可看下方演示gif图app:retryLoadAlways=&quot;true&quot;:是否开启数据为空时点击重试，默认为falseapp:showLoadingDebug=&quot;true&quot;:是否开启布局预览调试，默认为false，开启后可以在AS中正常预览布局文件，打包时请一定写false！其他更多属性请看 12345678910111213141516171819202122232425262728&lt;resources&gt; &lt;declare-styleable name=&quot;LoadingLayout&quot;&gt; &lt;!--设置数据为空的layout--&gt; &lt;attr name=&quot;emptyView&quot; format=&quot;reference&quot; /&gt; &lt;!--设置加载失败的layout--&gt; &lt;attr name=&quot;errorView&quot; format=&quot;reference&quot; /&gt; &lt;!--设置加载中的layout--&gt; &lt;attr name=&quot;loadingView&quot; format=&quot;reference&quot; /&gt; &lt;!--设置加载动画id--&gt; &lt;attr name=&quot;loadingAnimator&quot; format=&quot;reference&quot; /&gt; &lt;!--设置加载中的背景，或者颜色--&gt; &lt;attr name=&quot;loadingBackground&quot; format=&quot;reference|color&quot; /&gt; &lt;!--设置默认Progressbar的progress_drawable--&gt; &lt;attr name=&quot;loadingProgressDrawable&quot; format=&quot;reference&quot; /&gt; &lt;!--设置数据为空时的图片--&gt; &lt;attr name=&quot;emptyDrawable&quot; format=&quot;reference&quot; /&gt; &lt;!--设置数据为空时的提示语--&gt; &lt;attr name=&quot;emptyText&quot; format=&quot;string&quot; /&gt; &lt;!--设置加载失败时的图片--&gt; &lt;attr name=&quot;errorDrawable&quot; format=&quot;reference&quot; /&gt; &lt;!--设置加载失败时的提示语--&gt; &lt;attr name=&quot;errorText&quot; format=&quot;string&quot; /&gt; &lt;!--设置是否总是点击重试，无论数据为空或者失败，默认false--&gt; &lt;attr name=&quot;retryLoadAlways&quot; format=&quot;boolean&quot; /&gt; &lt;!--设置自动显示加载调试--&gt; &lt;attr name=&quot;showLoadingDebug&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; Activity&#x2F;Fragment代码中 123456789101112131415161718// 初始化布局对象 mLoadingLayout = (LoadingLayout) findViewById(R.id.loading_layout); // 加载完毕/加载成功 mLoadingLayout.loadComplete(); // 数据为空 mLoadingLayout.showEmpty(); // 加载失败 mLoadingLayout.loadFailure(); // 设置点击重试监听 mLoadingLayout.setOnRetryLoadListener(OnRetryLoadListener); // 显示加载中 // 代码调用了setLoadingView()，才需要手动调用showLoading()mLoadingLayout.showLoading(); 效果图加载中，加载完成，数据为空，加载失败，点击重试 几种状态演示gif注意事项 LoadingLayout需要依赖于appcompat-v7 &amp;support-annotations，请在工程中添加这两个依赖（版本可自定义，不建议低于25.3.1）： 12compile &quot;com.android.support:appcompat-v7:25.3.1&quot; compile &#x27;com.android.support:support-annotations:25.3.1&#x27; 项目地址感谢阅读，欢迎体验：https://github.com/xiong-it/LoadingLayout","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"开源","slug":"开源","permalink":"http://blog.michaelx.tech/tags/%E5%BC%80%E6%BA%90/"},{"name":"LoadingLayout","slug":"LoadingLayout","permalink":"http://blog.michaelx.tech/tags/LoadingLayout/"}]},{"title":"Android开发：RecyclerView平滑流畅的滑动到指定位置","slug":"Android开发：RecyclerView平滑流畅的滑动到指定位置","date":"2017-10-17T12:11:00.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-10/Android开发：RecyclerView平滑流畅的滑动到指定位置/","link":"","permalink":"http://blog.michaelx.tech/2017-10/Android%E5%BC%80%E5%8F%91%EF%BC%9ARecyclerView%E5%B9%B3%E6%BB%91%E6%B5%81%E7%95%85%E7%9A%84%E6%BB%91%E5%8A%A8%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE/","excerpt":"RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。","text":"RecyclerView.smoothScrollToPosition(int);滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth，本文将分享如何使得RecyclerView平滑流畅的滑动到指定位置。背景在项目中，想使RecyclerView慢慢的平缓滑动指定位置，于是使用： 1RecyclerView.smoothScrollToPosition(int); 发现效果并不理想，滑动过程很突兀，很快就滑动到了指定位置，并没有像函数名那样smooth（流畅的，平滑的），也就是说smoothScrollToPosition没有滑动效果，黑人问号？？？ 本文原创作者MichaelX，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 探索历程既然函数名是流畅平缓的滑动到指定位置，为什么并不理想呢？查看源码如下： 1234public void smoothScrollToPosition(int position) &#123; // ···省略无关代码，mLayout是该RecyclerView的LayoutManager对象 mLayout.smoothScrollToPosition(this, mState, position); &#125; 所以实际上是调用RecyclerView.LayoutManager.smoothScrollToPosition()方法，这是个抽象方法。由于笔者项目中是LinearLayoutManager于是找到其具体实现如下： 123456789@Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) &#123; LinearSmoothScroller smoothScroller = new LinearSmoothScroller(context); smoothScroller.setTargetPosition(position); startSmoothScroll(smoothScroller); &#125; 生成一个RecyclerView.SmoothScroller的子类LinearSmoothScroller对象smoothScroller，接着利用smoothScroller去完成剩下的滑动工作。 于是进去LinearSmoothScroller看看。重大发现—里面有一个跟滑动速度相关的函数： 123456789/** * Calculates the scroll speed. * 计算滑动速度 * 返回：滑过1px所需的时间消耗。 */protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123; // MILLISECONDS_PER_INCH是常量，等于20f return MILLISECONDS_PER_INCH / displayMetrics.densityDpi;&#125; 既然RecyclerView.smoothScrollToPosition(int);很快，是不是延长其滑动时间就可以呢？ 解决smoothScrollToPosition无效为了验证上节延长滑动时间的想法，自定义一个LinearLayoutManager: 1234567891011121314151617181920212223public class SmoothScrollLayoutManager extends LinearLayoutManager &#123; public SmoothScrollLayoutManager(Context context) &#123; super(context); &#125; @Override public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, final int position) &#123; LinearSmoothScroller smoothScroller = new LinearSmoothScroller(recyclerView.getContext()) &#123; // 返回：滑过1px时经历的时间(ms)。 @Override protected float calculateSpeedPerPixel(DisplayMetrics displayMetrics) &#123; return 150f / displayMetrics.densityDpi; &#125; &#125;; smoothScroller.setTargetPosition(position); startSmoothScroll(smoothScroller); &#125; &#125; Binggo！成功！调用RecyclerView.smoothScrollToPosition(int);发现滑动速度变慢很多，不再突兀，不再突然滑过去，没有任何过渡，而是缓慢滑过去，终于名副其实的smooth。 本文原创作者MichaelX，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 结语通过自定义LinearLayoutManager，重写smoothScrollToPosition()方法中LinearSmoothScroller对象的calculateSpeedPerPixel(DisplayMetrics)方法,可以使RecyclerView.smoothScrollToPosition(int);平滑的流畅的滑动到指定位置。其他LayoutManager暂时没用到，需要读者自己尝试。 如果读者朋友们有其他的办法，欢迎留言交流。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://blog.michaelx.tech/tags/RecyclerView/"}]},{"title":"Android开发小记：编译ijkplayer以支持更多视频格式","slug":" Android开发小记：编译ijkplayer以支持更多视频格式","date":"2017-09-22T13:11:02.000Z","updated":"2022-12-02T03:10:42.353Z","comments":true,"path":"2017-09/ Android开发小记：编译ijkplayer以支持更多视频格式/","link":"","permalink":"http://blog.michaelx.tech/2017-09/%20Android%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%EF%BC%9A%E7%BC%96%E8%AF%91ijkplayer%E4%BB%A5%E6%94%AF%E6%8C%81%E6%9B%B4%E5%A4%9A%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/","excerpt":"ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。","text":"ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。前言ijkplayer大法好，感谢B站大佬。ijkplayer基于FFmpeg开发，适配Android&#x2F;iOS平台。FFmpeg在开发界简直是神一般存在的项目，全平台全格式音视频编解码支持。像前段时间“杀程序员祭天”的暴风，受众颇广的QQ影音都是FFmpeg的受益者，因为不遵循GNU LGPL协议，也是FFmpeg项目耻辱柱上的成员。但是ijkplayer默认是不支持播放av的，呵呵，台词错了，是avi，今天分享下自己编译ijkplayer以支持avi，mpeg&#x2F;mpg等更多格式视频。 前提条件生产环境是MacOS或者Linux系统，笔者是MacOS，Android 6.0，这里以Mac为例记下自己编译ijkplayer for Android的过程。build ijkplayer for Android. 编译准备 安装homebrew：ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装git：brew install git 安装yasm：brew install yasm 下载ijkplayer项目：git clone https://github.com/Bilibili/ijkplayer.git 替换支持格式编译脚本： 123cd ijkplayer/configrm module.sh # 这是一个软链接，默认指向module-lite.shln -s module-default.sh module.sh 设置编译环境变量：在终端执行以下命令（具体请指向自己的路径） 12export ANDROID_NDK=/Users/michaelx/Library/Android/sdk/ndk-bundleexport ANDROID_SDK=/Users/michaelx/Library/Android/sdk 官方建议NDK版本为r10e，笔者为r13.1，MacOS 10.12.6 ，实测通过编译。 开始编译cd进入项目根目录 12345678910bash init-android.shcd android/contrib# 执行以下两条命令./compile-ffmpeg.sh clean# 如果默认shell不是bash，建议执行以下命令bash compile-ffmpeg.sh clean./compile-ffmpeg.sh all# 如果默认shell不是bash，建议执行以下命令bash compile-ffmpeg.sh all 执行过程中出现的以下类似提示可忽略： 123456789WARNING: aarch64-linux-android-pkg-config not found, library detection may fail.--------------------[*] compile ffmpeg--------------------libavfilter/avfiltergraph.c: In function &#x27;avfilter_graph_free&#x27;:libavfilter/avfiltergraph.c:132:5: warning: &#x27;resample_lavr_opts&#x27; is deprecated (declared at libavfilter/avfilter.h:847) [-Wdeprecated-declarations] av_freep(&amp;(*graph)-&gt;resample_lavr_opts); ^ 出现以下提示时FFmpeg编译完了: 12345--------------------[*] Finished--------------------# to continue to build ijkplayer, run script below,sh compile-ijk.sh 那我们就可以编译ijkplayer拿到so动态库文件。按照提示执行: 123bash compile-ijk.sh# orsh compile-ijk.sh 出现以下提示表示ijkplayer编译完毕: 12345678910111213141516[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= BPMDetect.cpp[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= PeakFinder.cpp[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= SoundTouch.cpp[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= mmx_optimized.cpp[armeabi-v7a] Compile++ thumb: ijksoundtouch &lt;= ijksoundtouch_wrap.cpp[armeabi-v7a] Install : libijkffmpeg.so =&gt; libs/armeabi-v7a/libijkffmpeg.so[armeabi-v7a] StaticLibrary : libcpufeatures.a[armeabi-v7a] StaticLibrary : libijkj4a.a[armeabi-v7a] StaticLibrary : libandroid-ndk-profiler.a[armeabi-v7a] StaticLibrary : libijksoundtouch.a[armeabi-v7a] StaticLibrary : libyuv_static.a[armeabi-v7a] SharedLibrary : libijksdl.so[armeabi-v7a] SharedLibrary : libijkplayer.so[armeabi-v7a] Install : libijksdl.so =&gt; libs/armeabi-v7a/libijksdl.so[armeabi-v7a] Install : libijkplayer.so =&gt; libs/armeabi-v7a/libijkplayer.so/Users/michealx/Documents/ijkplayer/android 进入ijkplayer/android/ijkplayer/armeabi-v7a/ 就可以拿到编出来的ijkplayer so了，那么编出来的ijkplayer so怎么用到项目当中呢？接着看。 使用编译的ijkplayer so库ijkplayer的默认用法如下： 12compile &#x27;tv.danmaku.ijk.media:ijkplayer-java:0.8.3&#x27;compile &#x27;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.3&#x27; 第二个依赖没有任何代码，实际只是so库，既然要使用自己编译出来的so，那么第二个依赖可以去掉： 12compile &#x27;tv.danmaku.ijk.media:ijkplayer-java:0.8.3&#x27;// compile &#x27;tv.danmaku.ijk.media:ijkplayer-armv7a:0.8.3&#x27; 将自己编译出来的3个so文件放入项目的main/jniLibs/armeabi-v7a/下即可。播放代码无需做任何改变，现在ijkplayer就可以播放avi，mpeg&#x2F;mpg多更多格式视频了。 至于ijkplayer更多玩法，笔者也还在探索，如果后续有空笔者会陆续更新。 传送门基于ijkplayer 0.8.3编译的Android so库（比默认依赖支持更多格式）:github:compiled_ijkplayer4android(后续会根据ijkplayer版本持续更新) 致谢Bilibili&#x2F;ijkplayer","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"ijkplayer","slug":"ijkplayer","permalink":"http://blog.michaelx.tech/tags/ijkplayer/"}]},{"title":"Android开发：使用AutoInputAuthCode快速实现自动填写验证码","slug":"Android开发：使用AutoInputAuthCode快速实现自动填写验证码","date":"2017-05-09T09:36:18.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-05/Android开发：使用AutoInputAuthCode快速实现自动填写验证码/","link":"","permalink":"http://blog.michaelx.tech/2017-05/Android%E5%BC%80%E5%8F%91%EF%BC%9A%E4%BD%BF%E7%94%A8AutoInputAuthCode%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"使用AutoInputAuthCode快速实现自动填写验证码","text":"使用AutoInputAuthCode快速实现自动填写验证码前言该类库的实现原理:《Android开发:实现APP自动填写注册验证码功能》。感兴趣的可以看下。 项目地址：https://github.com/xiong-it/AutoInputAuthCode 本文原创作者:MichaelX,博客地址:http://blog.csdn.net/xiong_it.转载请注明来源 AutoInputAuthCode使用介绍在Android Studio打开你的app module中的build.gradle,添加依赖： 12345dependencies &#123; ... compile &#x27;tech.michaelx.authcode:authcode:1.0.0&#x27; // 添加依赖 ...&#125; 如果无法下载上述依赖，可以打开你的项目根目录下的build.gradle，添加maven仓库地址 123456allprojects &#123; repositories &#123; jcenter() maven &#123; url &#x27;https://dl.bintray.com/xiong-it/AndroidRepo&#x27;&#125; // 添加这行 &#125;&#125; 示范代码AutoInputAuthCode是一个帮助Android开发者快速实现自动填写验证码的类库，客户端示例代码如下： 123456789CodeConfig config = new CodeConfig.Builder() .codeLength(4) // 设置验证码长度 .smsFromStart(133) // 设置验证码发送号码前几位数字 //.smsFrom(1690123456789) // 如果验证码发送号码固定，则可以设置验证码发送完整号码 .smsBodyStartWith(&quot;百度科技&quot;) // 设置验证码短信开头文字 .smsBodyContains(&quot;验证码&quot;) // 设置验证码短信内容包含文字 .build(); AuthCode.getInstance().with(context).config(config).into(EditText); 通过单例获取一个AuthCode对象; 提供一个上下文对象给AuthCode，放心，我会妥善处理你的上下文; 提供一个你的验证码特征描述; 告诉AuthCode你想将验证码写入哪个EditText. 搞定，收工！ 效果图 注意事项自动填写验证码需要读取短信权限，请在清单中添加权限： 12&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt; 由于读取短信在API 23（Android 6.0）上权限级别是dangerous。所以还需要动态申请权限，但是申请权限需要依赖于Activity或者Fragment中的onRequestPermissionsResult()回调，所以需要开发者自己实现。 可参考AutoInputAuthCode中sample的代码。 该库实现原理请参考：《Android开发:实现APP自动填写注册验证码功能》 总结该库实际上被完成有一段时间了，一直在试着上传jcenter，有空把上传代码到jcenter总结下发出来，虽然上传jcenter在网上教程挺多的，但是很多都不够细节，容易误解，我就是被坑的一个。 祝大家撸码愉快！项目地址：https://github.com/xiong-it/AutoInputAuthCode","categories":[{"name":"开源","slug":"开源","permalink":"http://blog.michaelx.tech/categories/%E5%BC%80%E6%BA%90/"}],"tags":[{"name":"AutoInputAuthCode","slug":"AutoInputAuthCode","permalink":"http://blog.michaelx.tech/tags/AutoInputAuthCode/"},{"name":"验证码","slug":"验证码","permalink":"http://blog.michaelx.tech/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"}]},{"title":"科学上网:安装Shadowsocks Server on VPS","slug":"科学上网-安装Shadowsocks-Server-on-VPS","date":"2017-05-03T08:46:37.000Z","updated":"2022-12-02T03:10:42.356Z","comments":true,"path":"2017-05/科学上网-安装Shadowsocks-Server-on-VPS/","link":"","permalink":"http://blog.michaelx.tech/2017-05/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%AE%89%E8%A3%85Shadowsocks-Server-on-VPS/","excerpt":"作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外","text":"作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外前言作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外。科学上网的方法大致如下几种： 修改本机hosts，可访问的网站有限 vpn：容易被封 shadowsocks-俗称：影梭 etc… 简单介绍其中修改hosts的方法成本最低，也最简单，网上找到需要访问网站的ip，写进本机hosts文件中即可。这样访问被|墙网站时，机器先访问hosts文件，发现已经有ip了，就不会访问dns服务器去要求解析域名了，而是直接根据指定ip去访问被|墙网站。 vpn的方式由于其容易被探测的缘故，容易被封。 根据socks5代理方式实现的shadowsocks项目，由于其隐蔽性存活至今。其需要一外国的服务器上装shadowsocks服务端实现流量中转，然后本地机器装shadowsocks客户端进行科学上网。当然网上也有很多的shadowsocks账号购买，服务器它给你搭好了，然后就售卖账号，但是也存在些骗子收完钱跑路的，拿着账号上不了网，当然也存在奸商超售账号的情况，许多人买完账号挤在一个服务器上爬蜗牛。那么为什么不自己搭一个shadowsocks服务端呢？更何况年付的价钱不比你购买账号贵！服务器还在自己手里，不怕隐私泄露。 什么是vps笔者理解也不深，感觉就是虚拟主机的升级版，可拥有独立ip，但又不是独立服务器，是一台服务器上利用虚拟化技术独立出来的单独机器，购买这台vps后，你自己就可以对这台机器做任意操作：重装系统（Linux，Windows），装任意软件，拥有root权限，可远程操控都不在话下。总之和一台远程服务器差不多。但是价格却远低于服务器价格。搬瓦工VPS的介绍翻译如下： 隶属于美国IT7公司旗下的一款低价OpenVZ VPS主机方案、2017年新增KVM VPS架构，尤其是6款便宜年付VPS，无论从性价比还是稳定性都非常适合大众VPS用户需求，我们可以用来建站、搭建上网环境 官网：性价比高*搬瓦工vps 笔者购买的是最便宜的年付19刀（人民币130左右）的512M内存，10G ssd硬盘，100G宽带方案，难能可贵的是搬瓦工vps：可使用支付宝支付，据说是2016年推出的新功能，之前只能使用PayPal支付。 购买搬瓦工VPS 打开搬瓦工官网：性价比高*搬瓦工vps 点击要购买的的套餐下方的 订购按钮“order Now”， 进入如下图示界面，选择付账周期Billing Cycle（月付，季付，半年付，年付），和节点Location（洛杉矶，佛罗里达等），洛杉矶的节点还行，比较稳定。最后点击Add to Cart加入购物车，之后下一个界面点击check out结账。 注册账号有几点： 资料是否完全真实无所谓，姓名可以随意填 邮箱必须自己的，以免以后找回密码需要 国家、地区、省份必须真实 街道等详细地址你随意填写，电话也可以随意。不能用V&#x3D;P&#x3D;N软件更换IP购买，用真实的IP购买就可以。 Pay Method中选择Alipay即支付宝，勾选下方的协议 点击Complete Order结账 手机支付宝扫二维码，完事 搬瓦工VPS安装shadowsocks服务端 点击图中的Client Area，登陆账号 查看服务 点击右边的KiviVM Control Panel进入vps控制面板 安装shadowsocks Server ss客户端使用ss客户端下载ss客户端使用 参考博客https://b.lhuac.com/2/","categories":[{"name":"科学上网","slug":"科学上网","permalink":"http://blog.michaelx.tech/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://blog.michaelx.tech/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://blog.michaelx.tech/tags/Shadowsocks/"}]},{"title":"Ubuntu 14.04编译AOSP for Nexus/Pixel","slug":"Ubuntu-14-04编译AOSP-for-Nexus-Pixel","date":"2017-03-14T03:29:09.000Z","updated":"2022-12-02T03:10:42.356Z","comments":true,"path":"2017-03/Ubuntu-14-04编译AOSP-for-Nexus-Pixel/","link":"","permalink":"http://blog.michaelx.tech/2017-03/Ubuntu-14-04%E7%BC%96%E8%AF%91AOSP-for-Nexus-Pixel/","excerpt":"为你手中的Nexus,Pixel手机刷入自己的专属Rom","text":"为你手中的Nexus,Pixel手机刷入自己的专属Rom前言虽说几年前博主在一家公司做机顶盒的时候总是需要编译Android源码，但是那时还没有手中的爱机：Nexus 6，又名shamu。今天我要为它刷入一个自己编译的Rom。拿起键盘就是干。 笔者注：AOSP:Android Open Source Project，安卓开源项目 准备 Ubuntu 14.04+ OpenJDK&#x2F;JDK Nexus&#x2F;Pixel手机一部 假设你已经有了一个较新的Ubuntu系统和一部谷歌亲儿子手机，下文将从安装jdk开始。 本文作者MichaelX，博客地址：http://blog.csdn.net/xiong_it ，转载请注明出处。 AOSP编译环境搭建安装OpenJDK 警告：不要使用oracle jdk来编译较新（API 21+&#x2F;Android 5.0及以上）的AOSP，会在准备编译工作make clobber时出现错误提示. Checking build tools versions... ************************************************************* You asked for an OpenJDK based build but your version is java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment(build 1.8.0_121-b13)Java HotSpot (TM)64 bit Server VM(build 25.121-b13), mixed mode). ************************************************************* build/core/main.mk:230: *** stop. 关于JDK版本的选择：根据你想编译的Android版本来决定 AOSP最新源码: OpenJDK 8 Android 5.x (Lollipop) - Android 6.0 (Marshmallow):OpenJDK 7 Android 2.3.x (Gingerbread) - Android 4.4.x(KitKat):Java JDK 6 Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Java JDK 5 博主想要编译的是Android 7.0，所以需要使用是OpenJDK 8。 博主是用的Ubuntu 14.04 LTS，可采取安装deb包或者添加ppa两种方式安装OpenOJDK 8： OpenJDK deb包下载:OpenJDK 8 on github 添加ppa方式安装OpenJDK1234567$ sudo add-apt-repository ppa:openjdk-r/ppa$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk$ sudo update-alternatives --config java$ sudo update-alternatives --config javac 假如你Ubuntu是15.04或者更新的系统，可直接运行下列命令进行OpenJDK 8安装 12$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk Linux使用下列命令查看机器中所有jdk版本 123$ michaelx@michaelx-ThinkPad:~/AOSP_NBD91Z$ update-java-alternatives -l// 打印出下面已安装的jdk版本java-1.8.0-openjdk-amd64 1069 /usr/lib/jvm/java-1.8.0-openjdk-amd64 Linux设置默认JDK命令 123456// 设置默认为openjdk8，此处必须选用OpenJDK8$ sudo update-java-alternatives -s java-1.8.0-openjdk-amd64// 设置默认为oracle jdk8$ sudo update-java-alternatives -s java-8-oracle// 设置默认为oracle jdk7$ sudo update-java-alternatives -s java-7-oracle Ubuntu 14.04设置默认OpenJDK 8时出现一处警告提示： update-java-alternatives: plugin alternative does not exist: /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/IcedTeaPlugin.so 该提示无需理会，可直接忽略。 查看Java版本，出现以下提示，说明jdk环境已经ok。 12345$ java -versionopenjdk version &quot;1.8.0_111&quot;OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-3~14.04.1-b14)OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode) 如果实在切换不了默认jdk，就像博主一样，卸了oracle jdk吧。 安装必要软件在你的Ubuntu 14(x64)上执行以下命令 1234$ sudo apt-get install git-core gnupg flex bison gperf build-essential \\ zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \\ lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \\ libgl1-mesa-dev libxml2-utils xsltproc unzip 会有些已经安装，有些无法安装，或者安装失败，无需理会，继续往下。其他系统版本系统请直接参考：Establishing a build environment 配置USB访问权限ps：不知道这个干啥的，但是官方是这么建议的，为了让普通用户可访问usb设备。 1$ wget -S -O - http://source.android.com/source/51-android.rules | sed &quot;s/&lt;username&gt;/$USER/&quot; | sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules 安装repo安装repo以下载AOSP源码。repo是Google根据git开发来专门管理Android源码用的，具有断点续传的特性。其主要命令可参考：git&#x2F;repo常用命令一览。依次执行下面命令。 123456$ cd ~$ mkdir bin$ PATH=~/bin:$PATH$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo # 给repo添加执行权限 配置git由于需要下载Android源码，你需要事先准备好一个google的gmail邮箱。执行以下命令配置git用户名和gmail邮箱。 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;you@gmail.com&quot; 配置Google的git cookies访问权限，以便大量下载aosp源码站点资源。https://android.googlesource.com/new-password复制框中的命令,粘贴到终端,执行。 下载AOSP源码创建一个目录以存放Android源码 12$ mkdir ~/AOSP_NBD91Z # 目录名请自行定义，本文以AOSP_NBD91ZNBD91Z为例$ cd AOSP_NBD91Z 根据手中的机器和以下两个连接进行repo分支选择：https://source.android.com/source/build-numbers.htmlhttps://developers.google.com/android/nexus/drivers AOSP源码编译默认是不适配驱动的，只适合模拟器运行，由于博主想要为Nexus 6编译，所以需要考虑驱动问题，根据上文第二个链接找到shamu的最新驱动，目前（20170307）最新的驱动支持到build NBD91Z，将驱动下载下来，留着备用。在第一个链接中找到对应的branch name（android-7.0.0_r29）。 在AOSP本地目录初始化repo分支 12$ cd ~/AOSP_NBD91Z$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.0.0_r29 下载&#x2F;续传AOSP源码无论是第一次开始下载，还是中途断掉后接着续传下载，都是执行以下命令。 1$ repo sync 之后就是漫长的等待了，该分支（android-7.0.0_r29）代码总共约80G（含版本管理文件.repo目录46G）。这里提醒下各位，分区的时候一定记得至少至少至少给到120G啊，80G还不是最新分支的大小呢。编译后更加大得多：该分支编译出的out目录共30G左右。不过下载完成后，如果没什么版本控制的需要 .repo目录倒是可以删除掉，节省点硬盘空间。 编译AOSP预备工作设置编译缓存（可选操作）可加速后续第二次编译，如需要，可在源码目录执行以下命令 123$ export USE_CCACHE=1$ export CCACHE_DIR=~/AOSP_NBD91Z/.ccache # 目录自定义$ prebuilts/misc/linux-x86/ccache/ccache -M 50G # 官方推荐50-100G 更新环境变量 12345$ vim ~/.bashrc# 添加以下这行export USE_CCACHE=1$ source ~/.bashrc 释放手机驱动将上述下载的几个驱动文件解压到源码根目录，解压后也就是几个脚本文件，依次执行，以释放驱动，画风大概如下 共8大条款，几十个小条款，一行行回车按过去，心累啊。 划重点：在执行驱动脚本后，会让你看一大长串协议，最后你需要输入：I ACCEPT 来同意驱动的协议，方可释放驱动文件。按回车按快了则提示你没有同意，驱动未释放成功。成功之后会多出一个vendor目录。 清理编译文件驱动释放完毕，先执行make clobber清理下编译后文件的目录，第一次编译其实博主觉得这个命令无所谓。 相似命令：make clean 它清理out&#x2F;target&#x2F;product&#x2F;[product_name]目录。 编译AOSP准备好编译平台 1234$ cd AOSP_NBD91Z$ source build/envsetup.sh# or 或者，上面的命令和下面的命令等价$ . build/envsetup.sh 选择编译平台执行上述命令后方可执行这条命令lunch由于笔者手中是Nexus 6（shamu），所以果断选择了21 关于几种模式的区别 user 正常模式，给普通用户用的 userdebug 具备root权限和更多调试功能，其他和user模式无异 eng 开发者的最佳选项，具有许多额外的调试工具 正式编译AOSP源码运行make进行编译，也可以使用-j选项指定并行编译线程数量 1234# 利用6个线程进行编译。官方建议的最快并行线程数量为：j16-j32之间。$ make -j6 # 请各位根据自身CPU性能量力而行。博主曾经使用-j16导致GUI界面和终端统统卡死，只能强制关机，心疼我的ssd硬盘30s。 又是一次漫长的等待啊，如果不出什么问题，那么在out/target/product/[product_name]/目录下将会多出诸如system.img，recovery.img等等，就可以愉快的刷机了。 下面是生成的各种镜像文件和其他。 编译AOSP遇到的问题权限遭拒由于博客使用了外部硬盘作为out编译输出，make时提示Permission is denied。这时换成sudo make即可。 使用外部磁盘做out输出：export OUT_DIR_COMMON_BASE&#x3D;&#x2F;media&#x2F;username&#x2F;外部磁盘路径&#x2F;out 内存不足由于笔者的内存只有4G，并且最开始没有分出swap分区，导致多次内存不足编译失败，有多种日志形式都表明内存不足： 第1种错误：[ 34% 12287/35393] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Communication error with Jack server (52). Try &#39;jack-diagnose&#39; ninja: build stopped: subcommand failed. make: *** [ninja_wrapper] Error 1 第2种错误：[ 82% 30024/36285] Aligning zip: out/target/product/shamu/obj/SHARED_LIBRARIES/libdlext_test_runpath_zip_zipaligned_intermediates/libdlext_test_runpath_zip_zipaligned.zip [ 82% 30025/36285] Import includes file: out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/import_includes [ 82% 30026/36285] target thumb C++: libverifier &lt;= bootable/recovery/asn1_decoder.cpp [ 82% 30027/36285] target thumb C++: libverifier &lt;= bootable/recovery/verifier.cpp [ 82% 30028/36285] Export includes file: -- out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/export_includes [ 82% 30029/36285] target thumb C++: libverifier &lt;= bootable/recovery/ui.cpp ninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1 第3种错误：FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Out of memory error (version 1.2-rc4 &#39;Carnac&#39; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)). GC overhead limit exceeded. Try increasing heap size with java option &#39;-Xmx&lt;size&gt;&#39;. Warning: This may have produced partial or corrupted output. [ 31% 11494/36285] host C++: libartd-compiler &lt;= art/compiler/optimizing/graph_visualizer.cc [ 31% 11494/36285] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/libprotobuf-java-nano_intermediates/classes.jack [ 31% 11494/36285] build out/target/common/obj/JAVA_LIBRARIES/sdk_v21_intermediates/classes.jack ninja: build stopped: subcommand failed. 第4种错误：[ 6% 2375/35393] target Java: icu4j (out/target/common/obj/JAVA_LIBRARIES/icu4j_intermediates/classes) Note: Some input files use or override a deprecated API. Note: Recompile with -Xlint:deprecation for details. Note: external/icu/icu4j/main/classes/core/src/com/ibm/icu/impl/Relation.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. [ 6% 2394/35393] host C++: libLLVMMC_32 &lt;= external/llvm/lib/MC/MCDwarf.cppninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1 第5种错误： 123456789101112[ 5% 1883/35393] Docs droiddoc: out/target/common/docs/api-stubsFAILED: /bin/bash out/target/common/docs/api-stubs-timestamp.rspOpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bdb80000, 72876032, 0) failed; error=&#x27;Cannot allocate memory&#x27; (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (mmap) failed to map 72876032 bytes for committing reserved memory.# An error report file with more information is saved as:# /home/michaelx/AOSP_NBD91Z/hs_err_pid508.log[ 5% 1883/35393] Docs droiddoc: out/target/common/docs/system-api-stubsDroidDoc took 27 sec. to write docs to out/target/common/docs/system-api-stubsninja: build stopped: subcommand failed.make: *** [ninja_wrapper] Error 1 解决内存不足的3个办法： 增加机器内存 增加swap分区 修改prebuild&#x2F;sdk&#x2F;tools&#x2F;jack-admin文件 第一种方式就不说了，给机器加根内存条，壕专享。第二种方式：增加swap分区：http://hancj.blog.51cto.com/89070/197915第三种方式： 12345678910# 备份jack-admin$ cp prebuild/sdk/tools/jack-admin ~/Docments/jack-admin.original# 修改jack-admin文件$ vim prebuild/sdk/tools/jack-admin# start-server方法，笔者的jack-admin在443行，修改该方法中的一句话：# JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;# 改成下面这行,增加java堆大小。JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx8000M -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot; 以上增加的-Xmx8000M，表示允许java在运行时java堆使用最大不超过8000M内存，这个数值是笔者经历了多次测试得到的结果，2048M，4096M，依旧没通过编译，改成8000M后编译通过，可能跟笔者自身硬件限制有很大关系 另一种修改方式：修改jack-admin第29行的变量：JACK_SERVER_VM_ARGUMENTS=&quot;$&#123;JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation&#125;&quot; 改成： JACK_SERVER_VM_ARGUMENTS=&quot;$&#123;JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation -Xmx8000M&#125;&quot; 但是这种修改方式仍然不好使，编译失败了。 笔者是尝试了第二，三种方式解决。 jack-server无法运行错误日志如下：[ 37% 13421/35393] Ensure Jack server is installed and started FAILED: /bin/bash -c &quot;(prebuilts/sdk/tools/jack-admin install-server prebuilts/sdk/tools/jack-launcher.jar prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 2&gt;&amp;1 || (exit 0) ) &amp;&amp; (JACK_SERVER_VM_ARGUMENTS=\\&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation\\&quot; prebuilts/sdk/tools/jack-admin start-server 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update server prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 4.8.ALPHA 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-2.28.RELEASE.jar 2.28.RELEASE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-3.36.CANDIDATE.jar 3.36.CANDIDATE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-4.7.BETA.jar 4.7.BETA || exit 47 )&quot; Jack server already installed in &quot;/home/michaelx/.jack-server&quot; Launching Jack server java -XX:MaxJavaStackTraceDepth=0 -Djava.io.tmpdir=/tmp -Dfile.encoding=UTF-8 -XX:+TieredCompilation -cp /home/michaelx/.jack-server/launcher.jar com.android.jack.launcher.ServerLauncher Jack server failed to (re)start, try &#39;jack-diagnose&#39; or see Jack server log No Jack server running. Try &#39;jack-admin start-server&#39; No Jack server running. Try &#39;jack-admin start-server&#39; [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/coptccal.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/compactdecimalformat.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/cpdtrans.cpp ninja: build stopped: subcommand failed. 解决Jack server failed to (re)start办法： 1234$ cd /prebuild/sdk/tools/$ jack-admin stop-server$ jack-admin start-server 和各路编译错误大战了7天7夜（真的是7天7夜呀，碰到的无数问题我都没写完呢），终于修成正果。 总结到了这里，相信大家都能轻松搞机了，如果有需要Nexus的刷机教程，请留言评论，下次出一篇Nexus的刷机过程。放2张Nexus 6刷机后的高清截图 本文原创作者:MichaelX,博客地址:http://blog.csdn.net/xiong_it.转载请注明来源 欢迎光临：MichaelX’s Blog 参考链接感谢AOSP官网：https://source.android.com/source/initializing.htmlAskUbuntu：http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-packageCSDN:http://blog.csdn.net/brightming/article/details/49763515 etc….","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.michaelx.tech/tags/Ubuntu/"},{"name":"AOSP","slug":"AOSP","permalink":"http://blog.michaelx.tech/tags/AOSP/"},{"name":"Nexus","slug":"Nexus","permalink":"http://blog.michaelx.tech/tags/Nexus/"},{"name":"Pixel","slug":"Pixel","permalink":"http://blog.michaelx.tech/tags/Pixel/"}]},{"title":"Android:BLE智能硬件开发详解","slug":"Android-BLE智能硬件开发详解","date":"2017-03-14T03:23:18.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-03/Android-BLE智能硬件开发详解/","link":"","permalink":"http://blog.michaelx.tech/2017-03/Android-BLE%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/","excerpt":"前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事","text":"前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事目录 前言 BLE是个什么鬼 BLE中的角色分工 主要的关键词和概念 GATT(Generic Attribute Profile ) Characteristic Service Android如何使用BLE 蓝牙权限 APP和BLE外设交互流程 后记 本文作者MichaelX，博客地址：http://blog.csdn.net/xiong_it 转载请注明来源 前言前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事。BLE是智能硬件的一种通讯方式，通过BLE连接，iOS &amp; Android手机和智能硬件就可以进行自定义的交互了。交互的体验如何，很大程度上取决于智能硬件的驱动工程师驱动写的好不好，以及App的代码质量如何。 笔者曾参与过多款BLE智能硬件的开发，许久不用，怕忘了，把自己的整理的一些知识记录与此，同时也希望能够给一些同学带来帮助。本文将尽力向读者讲清楚BLE是什么，以及在实际Android开发中该如何使用BLE。 前方高能：文章有点长，笔者经历了好几次改版，也花费了好几个月的业余时间，读者可能需要点耐心。着急的读者可直接跳转至**Android如何使用BLE** BLE是个什么鬼BLE：Bluetooth Low Energy,低功耗蓝牙。Android官方介绍如下： Android 4.3 (API Level 18) introduces built-in platform support for Bluetooth Low Energy in the central role and provides APIs that apps can use to discover devices, query for services, and read&#x2F;write characteristics. In contrast to Classic Bluetooth, Bluetooth Low Energy (BLE) is designed to provide significantly lower power consumption. This allows Android apps to communicate with BLE devices that have low power requirements, such as proximity sensors, heart rate monitors, fitness devices, and so on. 什么意思呢？自从API18&#x2F;Android4.3开始，Android开始支持低功耗蓝牙并给APP提供了一套api调用。相比传统蓝牙来说，BLE技术旨在降低蓝牙功耗。至于我们Android开发者来说，要做的就是调用这套api，和具备蓝牙的智能硬件沟通，通过蓝牙读写操控智能硬件。 BLE技术允许APP和那些有着低功耗需求的BLE设备进行通讯，这些设备包括但不限于：距离传感器设备，心跳率检测仪，健身器材，智能穿戴等。 约定:文中提到的”外设”,”BLE外设”和”智能硬件”是等价的.请读者知悉. 角色分工 Once the phone and the activity tracker have established a connection, they start transferring GATT metadata to one another. Depending on the kind of data they transfer, one or the other might act as the server. For example, if the activity tracker wants to report sensor data to the phone, it might make sense for the activity tracker to act as the server. If the activity tracker wants to receive updates from the phone, then it might make sense for the phone to act as the server. 在Android APP和BLE外设进行交互时,他们分别扮演两个角色.这两个角色是不固定的.GATT server:发送数据的一方.GATT client:接收数据的一方.当APP向外设写入数据时,APP就是server,外设就是client;当APP读取外设数据时,APP就是client.外设就是server. 主要的关键词和概念GATT(Generic Attribute Profile ) The GATT profile is a general specification for sending and receiving short pieces of data known as “attributes” over a BLE link. All current Low Energy APPlication profiles are based on GATT. 这个是BLE通讯的基本协议,这个协议定义了BLE发送和接收一小段数据的规范,这些被传输的小段数据被称为”attributes”. Characteristic A characteristic contains a single value and 0-n descriptors that describe the characteristic’s value. A characteristic can be thought of as a type, analogous to a class. 博主的理解中,”Characteristic”是BLE通讯之间的沟通”搬运工”,因为这是我们从智能硬件直接读写的东西,它依附于下文的Service存在，有自己的标志码：uuid。它『分为读取BLE外设数据的Characteristic &amp; 向BLE外设写入数据的Characteristic』。下面章节中将用代码说话. Service A service is a collection of characteristics. For example, you could have a service called “Heart Rate Monitor” that includes characteristics such as “heart rate measurement.” 此Service非彼Android四大组件中的彼Service,而是BluetoothGattService.这个Service是一个characteristics的集合,它可以理解为针对某个信号的通讯线路。 Android如何使用BLE蓝牙权限使用BLE需要两个权限 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 如果你想要APP只适配具备BLE的手机,那个可以再添加一个硬件权限特性 1&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt; APP和BLE外设交互流程APP和BLE外设交互的一个大概流程就是: BLE外设打开电源 APP初始化蓝牙 APP扫描周边BLE外设 APP连接到周边BLE外设 APP读写BLE外设 交互完成,APP向BLE外设写入关机&#x2F;待机指令(可选) BLE外设关机 APP关闭本地蓝牙连接 以下将逐步利用代码进行讲解APP和BLE外设交互. 初始化BLEJava代码判断当前手机是否支持BLE低功耗蓝牙 12345// 判断手机是否支持BLEif (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish();// 如果手机不支持BLE就关闭程序,仅供参考&#125; 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石. 123456// 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.private BluetoothAdapter mBluetoothAdapter;...final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);mBluetoothAdapter = bluetoothManager.getAdapter(); 跳转到系统蓝牙设置界面1234567private BluetoothAdapter mBluetoothAdapter;...// 验证蓝牙是否已打开,如果没打开就提示用户跳转打开.if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); &#125;APP扫描周边BLE外设需要实现一个BluetoothAdapter.LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：123456/** * @param device 被手机蓝牙扫描到的BLE外设实体对象 * @param rssi 大概就是表示BLE外设的信号强度，如果为0，则表示BLE外设不可连接。 * @param scanRecord 被扫描到的BLE外围设备提供的扫描记录，一般没什么用 */public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) 由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 private BluetoothAdapter mBluetoothAdapter; private boolean mScanning; private Handler mHandler; // 每扫描10s休息一下 private static final long SCAN_PERIOD = 10000; private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; // TODO 这里可以进行连接操作，连接操作见下一小节 if (device != null &amp;&amp; device.getName() != null &amp;&amp; device.getName().contain(&quot;你的产品名称&quot;))&#123; // 连接设备 connectDevice(device); // 停止扫描 scanLeDevice(false); &#125; &#125; &#125;); &#125;&#125;; ... /** * @param enable 是否进行扫描，false则停止扫描 */ private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; // 利用Handler进行间歇性扫描，每次扫描时间：10s mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); &#125; else &#123; // 停止扫描 mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; ... &#125;APP连接周边BLE外设连接操作是进行手机和BLE外设交互的基础，请看下面connectDevice(BluetoothDevice)方法实现。 分两步走： 判断该设备是否连接过，连接过则首先尝试直接连接：BluetoothGatt.connect() 首次连接或者直连失败使用：BluetoothDevice.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)123456789101112131415161718192021222324252627282930313233343536public boolean connectDevice(final BluetoothDevice device) &#123; if (mBluetoothAdapter == null || device == null) &#123; Log.w(TAG, &quot;BluetoothAdapter not initialized or unspecified address.&quot;); return false; &#125; String address = device.getAddress(); // 之前连接过的设备，尝试直接连接。mBluetoothDeviceAddress表示刚才连接过的设备地址 if (mBluetoothDeviceAddress != null &amp;&amp; address.equals(mBluetoothDeviceAddress) &amp;&amp; mBluetoothGatt != null) &#123; Log.d(TAG, &quot;Trying to use an existing mBluetoothGatt for connection.&quot;); if (mBluetoothGatt.connect()) &#123;// 连接成功 // 修改连接状态变量 mConnectionState = STATE_CONNECTING; return true; &#125; else &#123; return false; &#125; &#125; final BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(address); if (remoteDevice == null) &#123; Log.w(TAG, &quot;Device not found. Unable to connect.&quot;); return false; &#125; mBluetoothGatt = remoteDevice.connectGatt(context, false, mGattCallback); Log.d(TAG, &quot;Trying to create a new connection.&quot;); // 将当前连接上的设备地址赋值给连接过的设备地址变量 mBluetoothDeviceAddress = address; // 改变连接状态变量 mConnectionState = STATE_CONNECTING; return true; &#125; 连接BEL外设时，需要一个实现回调接口以得到连接状态，BluetoothGattCallback大概实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; // 该方法在连接状态改变时回调，newState即代表当前连接状态 String intentAction; // 连接上了 if (newState == BluetoothProfile.STATE_CONNECTED) &#123; intentAction = ACTION_GATT_CONNECTED; // 改变蓝牙连接状态变量 mConnectionState = STATE_CONNECTED; // 发送自定义广播：连接上了 broadcastUpdate(intentAction); // 当前外设相当于前面章节提到的Server角色：提供数据被手机读取 Log.i(TAG, &quot;Connected to GATT server.&quot;); // 获取读/写服务：Service。该方法会触发下面的onServicesDiscovered()回调 mBluetoothGatt.discoverServices(); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;// 断开连接了 intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); // 发送自定义广播：断开了连接 broadcastUpdate(intentAction); &#125; &#125; @Override // 该方法在蓝牙服务被发现时回调。由上述的mBluetoothGatt.discoverServices()触发结果。 public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; // 发现服务。status表示发现服务的结果码 if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); // TODO 从发现的Service来找出读数据用的BluetoothGattCharacteristic和写数据用的BluetoothGattCharacteristic。 initReadAndWriteCharacteristic(gatt.getServices()); &#125; else &#123;// 未发现服务 Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override // 读取操作的回调结果 public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); &#125; &#125; @Override // 写入操作的回调结果 public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; &#125;; ... &#125;;... **找出读写\"数据包\"的\"搬运工\"** 下面是找出读写”搬运工”BluetoothGattCharacteristic的initReadAndWriteCharacteristic()代码实现 1234567891011121314151617181920212223BluetoothGattCharacteristic mReadCharacteristic;BluetoothGattCharacteristic mWriteCharacteristic;public void initReadAndWriteCharacteristic( List&lt;BluetoothGattService&gt; gattServices) &#123; if (gattServices == null) return; // 遍历所有的 GATT Services. for (BluetoothGattService gattService : gattServices) &#123; if (!gattService.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的Service的uuid，由你司智能外色的驱动工程师决定&quot;)) continue; List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); // 遍历当前Service中所有的Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123; if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;&quot;这里是你期望的写数据的uuid，由你司驱动工程师决定&quot;&quot;)) &#123; mWriteCharacteristic = gattCharacteristic; &#125; else if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的读数据的uuid，由你司驱动工程师决定&quot;)) &#123; mReadCharacteristic = gattCharacteristic; &#125; &#125; &#125; &#125; 至此，我们就拿到了可携带读写数据的“搬运工”-『mReadCharacteristic &amp; mWriteCharacteristic』，下面就可以和智能硬件进行交互了。APP读取BLE外设蓝牙数据想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。123456789101112131415// 告诉”搬运工“我想知道BLE外设当前数据,将回调BluetoothGattCallback接口的onCharacteristicRead()方法mBluetoothGatt.readCharacteristic(mReadCharacteristic);// 读取BLE蓝牙数据操作的回调方法 @Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); // ”搬运工“把”数据包“搬出来了 byte[] data = characteristic.getValue(); // 根据驱动工程师给的协议文档，解析该数组，该处假设数组0位上表示心跳速率 int heartRateR = data[0];// 得到心跳速率，做相应UI更新和操作 &#125; &#125; &#125;APP向BLE外设写入数据比如说你想告诉BLE外设让他锁屏，或者进行某个动作，APP向操纵BLE外设时可通过以下方式 123456789101112131415// 根据驱动工程师给的协议文档，组织一个数组命令byte[] data = getData();// 将该条命令“数据包”给“搬运工&quot;mWriteCharacteristic.setValue(data);// ”搬运工“将数据搬到BLE外设里面了，将回调BluetoothGattCallback接口的onCharacteristicWrite()方法mBluetoothGatt.writeCharacteristic(characteristic);// 向BLE蓝牙外设写入数据操作的回调方法@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if(status == BluetoothGatt.GATT_SUCCESS) &#123; // 命令写入成功，数据包成功写入BLE外设中 &#125; &#125;; 多说一句，其实，手机关闭外设也是一条写入命令，外设得到该命令后即进入省电待机状态，一般外设也可以通过开&#x2F;关机键彻底关机。 APP关闭蓝牙连接 ----- 交互完了，不需要了，还是把APP蓝牙连接给断掉吧 1234567public void close() &#123; if (mBluetoothGatt == null) &#123; return; &#125; mBluetoothGatt.close(); mBluetoothGatt = null;&#125; 后记Android官方在SDK中提供了许多demo供开发者参考（1年前左右），其实关于BLE api调用也是有的,不过只涉及了蓝牙外设的连接,未涉及蓝牙数据读写.BLE官方demo路径:User/AndroidSDK/samples/android-19/connectivity/BluetoothLeGatt以上路径是笔者举例的路径,如果你的SDK目录下没有samples目录，现在（20170308）SDK Manager已经不开放sample下载了,请点击下载：android-sample-api19 文件提取密码: y87g 本文原创作者:MichaelX,博客地址:http://blog.csdn.net/xiong_it.转载请注明来源 欢迎光临：MichaelX’s Blog 参考链接https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"BLE","slug":"BLE","permalink":"http://blog.michaelx.tech/tags/BLE/"},{"name":"智能硬件","slug":"智能硬件","permalink":"http://blog.michaelx.tech/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6/"}]},{"title":"Design Patterns in Android：模板方法模式","slug":"Design-Patterns-in-Android：模板方法模式","date":"2017-02-10T17:16:27.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-02/Design-Patterns-in-Android：模板方法模式/","link":"","permalink":"http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。","text":"今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。前言今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。点击此处查看《Design Patterns in Android》系列其他文章。 本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 模板方式模式定义 模板方法模式(Template method pattern):定义一个操作中的算法框架，而将一些步骤延迟到子类中实现，使得子类可以不改变算法结构即可重新定义该算法的某些特定步骤 以上定义有两个关键词 算法框架：其本质是一个方法，也就是模板方法，它的调用会依次执行一些特定的步骤 特定步骤：其本质一系列抽象的方法，交由子类实现，以重新定义该算法细节 模板方法的UML类图 templateMethod：模板方法methodA,methodB：特定步骤 模板方法示例代码基类 12345678910111213public abstract class AbstractClass &#123; public void templateMethod() &#123; methodA(); methodB(); &#125; protected void abstract methodA(); protected void abstract methodB();&#125; 子类 1234567891011121314151617181920212223242526272829public class ConcreteClassA extends AbstractClass &#123; @Override protected void abstract methodA() &#123; System.out.println(&quot;ConcreteClassA.do something.&quot;); &#125; @Override protected void abstract methodB() &#123; System.out.println(&quot;ConcreteClassA.do other thing.&quot;); &#125;&#125;public class ConcreteClassB extends AbstractClass &#123; @Override protected void abstract methodA() &#123; System.out.println(&quot;ConcreteClassB.do something.&quot;); &#125; @Override protected void abstract methodB() &#123; System.out.println(&quot;ConcreteClassB.do other thing.&quot;); &#125;&#125; Android源码中模板方法模式在Android的api源码中，给我们提供了一个执行异步任务的类AsyncTask，其用法d大致如下 写一个自己的异步任务类（比如叫DownloadTask）继承自AsyncTask，主要复写onPreExecute(),doInBackground(),onPostExecute()等。 执行downloadTask 代码如下 1new DownloadTask().execute(url); 我们发现只要调用了execute（Params…）后，AsyncTask自动调用了各个回调方法了，onPreExecute(),doInBackground(),onPostExecute()等，其实这就是模板方法模式！下面我们通过一个android开发案例来弄懂模板方法。 Android开发中的模板方式模式实践Activity作为四大组件之首，是我们经常要使用到的，除非你的app不用和用户进行UI交互。那在多个Activity中，我们通常在onCreate()做一些程序化的事情 初始化控件 获取网络&#x2F;数据库数据 注册事件监听 注册广播 等等 在onDestroy()中 反注册广播 资源释放等 这时我们通常可以使用模板方法模式来抽象出一个BaseActityBaseFragment类似，不展开分析。实例代码如下 先写一个基类BaseActity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); initData(); initEvent(); registerBroadcast(); &#125; /** * 初始化视图控件 */ protected abstract void initView(); /** * 初始化数据 */ protected abstract void initData(); /** * 初始化点击长按等事件 */ protected abstract void initEvent(); /** * 注册广播接收者 */ protected void registerBroadcast() &#123; // 子类可以选择性复写 &#125; @Override public void onDestroy() &#123; super.onDestroy(); unRegisterBroadcast(); releaseMemory(); &#125; /** * 注销广播接收者 */ protected void unRegisterBroadcast() &#123; // 子类可以选择性复写 &#125; /** * 做些释放对象引用等其他操作以释放内存 */ protected abstract void releaseMemory();&#125; 随手写一个实现类MyActivity 123456789101112131415161718192021222324public class MyActivity extends BaseActivity &#123; @Override protected void initView() &#123; setContentView(resId); // TODO findViewById(); &#125; @Override protected void initData() &#123; // TODO 访问数据库/网络获取数据 &#125; @Override protected void initEvent() &#123; // TODO setOnClickListener &#125; @Override protected void releaseMemory() &#123; // TODO 把一些手动释放的对象值设为null someObj = null;// and so on. &#125;&#125; 如果再有一个其他Activity代码也是如此编写，以BaseActivity的onCreate(),onDestroy()为模板方法（算法框架），initView(),initData(),initEvent()等方法为特定步骤，利用模板方法构建了一个较好的基类，子类无需修改BaseActivity的算法框架，不同的Activity只需复写这些特定步骤即重新定义这些特定的细节步骤。 总结看完这篇《Design Patterns in Android：策略模式》，是不是很多人恍然大悟，原来模板方法就是这样啊！当编写一个方法时，其中包含了某些特定的步骤时，就可以考虑使用模板方法模式了。 好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"模板方法模式","slug":"模板方法模式","permalink":"http://blog.michaelx.tech/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"Template Method","slug":"Template-Method","permalink":"http://blog.michaelx.tech/tags/Template-Method/"}]},{"title":"Design Patterns in Android：策略模式","slug":"Design-Patterns-in-Android：策略模式","date":"2017-02-07T03:39:33.000Z","updated":"2022-12-02T03:10:42.355Z","comments":true,"path":"2017-02/Design-Patterns-in-Android：策略模式/","link":"","permalink":"http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","excerpt":"刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。","text":"刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。前言刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。点击此处查看《Design Patterns in Android》系列其他文章。 本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 策略模式定义 策略模式(Strategy pattern)：定义一组算法，将其各个封装，并且使他们有交换性。 策略模式好处在于使得算法在用户使用的时候能独立的改变，单一的修改，并且有良好扩展性。 算法：指的是各个策略的实现逻辑，而非算法领域的数据算法。 策略模式UML类图 策略模式各角色讲解 IStrategy：策略基类（接口或者抽象类），定义子策略需要实现的方法，比如excute()，该方法取决于客户端代码（高层代码）需要该策略实现什么功能，子类则实现该方法，封装自己的算法，供外部调用。 Context：此Context，非彼（Android中的）Context，它持有IStrategy真实的实例对象，提供给客户端调用IStrategy时的上下文调度者。 ConcreteStrategyA：实现父类IStrategy的方法，封装自身算法逻辑。 ConcreteStrategyB：同上 策略模式的示例代码IStrategy 123public interface IStrategy &#123; void excute();&#125; ConcreteStrategyA 12345public class ConcreteStrategyA implements IStrategy&#123; public void excute() &#123; System.out.println(&quot;1.我是ConcreteStrategyA的算法实现&quot;); &#125;&#125; ConcreteStrategyB 12345public class ConcreteStrategyB implements IStrategy&#123; public void excute() &#123; System.out.println(&quot;2.我是ConcreteStrategyB的算法实现&quot;); &#125;&#125; Context上下文角色 1234567891011public class Context &#123; private IStrategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void excute() &#123; this.strategy.excute(); &#125;&#125; 好了，下面是就是客户端代码，描述了如何使用策略模式Client 1234567891011public class Client &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.excute(); // context = new Context(new ConcreteStrategyB()); // context.excute(); &#125;&#125; 如上，客户端需要什么策略就new什么策略，完全取决于客户端需求，而且如果策略A出现问题，修改策略A就是了，和其他地方完全无关，如果现有策略不符合需求，再实现一个ConcreteStrategyA即可。 Android源码中的策略模式大家在使用Animation动画时，可以给Animation对象设置不同的插值器（Interpolator）来实现动画快慢速度动态效果。 比如：LinearInterpolator，线性插值器，实现匀速动画AccelerateDecelerateInterpolator：加速减速插值器，实现开始加速，结尾时减速的动画 BaseInterpolator类：Interpolator的实现类，就是速度插值器策略的基类 12345678910111213141516171819/** * An abstract class which is extended by default interpolators. */abstract public class BaseInterpolator implements Interpolator &#123; private int mChangingConfiguration; /** * @hide */ public int getChangingConfiguration() &#123; return mChangingConfiguration; &#125; /** * @hide */ void setChangingConfiguration(int changingConfiguration) &#123; mChangingConfiguration = changingConfiguration; &#125;&#125; Animation：Context上下文角色 12345678910111213141516public abstract class Animation implements Cloneable &#123; // ... // 省略无关代码 // ... private Interpolator mInterpolator; /** * Sets the acceleration curve for this animation. Defaults to a linear * interpolation. * * @param i The interpolator which defines the acceleration curve * @attr ref android.R.styleable#Animation_interpolator */ public void setInterpolator(Interpolator i) &#123; mInterpolator = i; &#125;&#125; LinearInterpolator等子类就实现了各自速度快慢的算法逻辑 12345678910111213@HasNativeInterpolatorpublic class LinearInterpolator extends BaseInterpolator &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; return input; &#125;&#125; 现在，我们给一个ImageView添加View动画 12345ImageView view;Animation animation = getResources().getAnimation(R.anim.pop_anim);// 给view的动画设置一个插值器策略animation.setInterpolator(new LinearInterpolator());view.startAnimation(animation); Android开发中的策略模式实践需求，现在你开发的Android app需要实现盈利，PM经过一番规划，想要你接入微信支付，支付宝支付，银联支付等移动端通用支付方式。 这个功能好实现，接入相关支付SDK即可，问题就在如何优雅的实现这个功能呢？ 延伸阅读：《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》《 Android App支付系列（二）：支付宝SDK接入详细指南(附官方支付demo)》 以下是笔者是实现，供各位读者参考。 PayActivity：客户端角色，支付方式选择界面 AbsPayStrategy：作为支付策略基类，定义了一个pay方法 PayContext：上下文角色，用来封装支付AbsPayStrategy对象 WeChatPayStrategy：封装了微信支付算法逻辑 ALiPayStrategy：封装了支付宝支付算法逻辑 BankCardPayStrategy：封装了银行卡支付算法逻辑 支付功能的示意代码AbsPayStrategy的实际实现应该为抽象类，它需要持有Activity对象。 12345public interface AbsPayStrategy &#123; // private Activity mActivity; // 本策略主要就是实现支付功能 void pay();&#125; Context上下文角色 1234567891011public class PayContext &#123; private AbsPayStrategy mPayStrategy; public PayContext(AbsPayStrategy payStrategy) &#123; mPayStrategy = payStrategy; &#125; public void pay() &#123; mPayStrategy.pay(); &#125;&#125; 微信支付策略实现 12345678910/** * 微信支付策略 */public class WeChatPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装微信支付逻辑 // 具体请参考笔者的博文《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》 &#125;&#125; 支付宝支付策略实现 12345678910/** * 支付宝支付策略 */public class ALiPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装支付宝支付逻辑 // 具体请参考笔者的博文《 Android App支付系列（二）：支付宝支付SDk接入详细指南(附官方支付demo)》 &#125;&#125; 具体的客户端代码，此处为PayActivity 123456789101112131415161718192021222324252627public class PayActivity extends Activity implements View.OnclickListener&#123; private PayContext mPayContext; @Override public void onClick(View view) &#123; switch(v.getId()) &#123;// 客户端来决定使用哪种支付策略 case R.id.wechat_pay: mPayContext = new PayContext(new WechatPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(new ALiPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(BankCardPayStrategy()); break; default: mPayContext = new PayContext(new WechatPayStrategy()); break; &#125; // 利用实际的支付策略对象进行支付 mPayContext.pay(); &#125; &#125; 这样就实现了一个app内的支付功能，如果微信支付出现问题了，改动微信支付策略代码，支付宝支付出现问题，改动想要实现即可，职责单一。 如果PM有一天说：我们需要接入百付宝，京东支付。怎么办？简单啊，实现相应的支付策略即可，完美适应需求变更，实现功能扩展。 总结如果在开发某功能时，可能出现多种平等的选择，可以考虑使用策略模式实现。 好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.michaelx.tech/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"Strategy","slug":"Strategy","permalink":"http://blog.michaelx.tech/tags/Strategy/"}]},{"title":"Design Patterns in Android：单例模式","slug":"Design-Patterns-in-Android：单例模式","date":"2017-01-17T08:11:02.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-01/Design-Patterns-in-Android：单例模式/","link":"","permalink":"http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用","text":"这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用前言这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将遵循以下模式，循序渐进的向读者讲解设计模式在Android开发的实践应用： 给出设计模式的定义和使用场景 给出设计模式的UML类图 给出该设计模式的简单Java代码 给出该设计模式在Android源码中的应用分析 给出该设计模式在Android应用开发中的实践 本文原创作者xiong_it，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 单例模式定义 单例模式(Singleton pattern):确保一个类只有一个实例，并提供对该实例的全局访问。 根据其定义，它的使用场景：当你需要创建一个对象，但是创建这个对象时需要消耗大量的系统资源，或者这个对象迫于某种原因只能在内存中存在一个实例的时候，单例模式也许是个不错的创建方案。 单例模式UML类图Singleton类作为单例类，它耦合了自身成员变量，并对外提供了一个公开方法getInstance()对instance对象的全局访问。 单例模式代码示例众所周知，单例模式有多个变种，但是最常见的还是“饿汉式”及“懒汉式”2种。本处示例代码以线程安全的饿汉式举例。 1234567891011121314public class Singleton &#123; private static Singleton sInstance = new Singleton(); private Singleton() &#123; super(); &#125; public static Singleton getInstance() &#123; if(sInstance == null) &#123; sInstance = new Singleton(); &#125; return sInstance; &#125;&#125; 单例模式注意事项主要有3点： 如果处于多线程环境，注意保持线程安全，不然就无法保证单例了 单例模式的默认构造方法的修饰符需改为private，只能类内部访问，确保外部不能直接new出该实例 单例模式需要提供一个全局访问入口，这个入口通常以getInstance()的public静态方法形式呈现 Android源码中的单例模式InputMethodManager是用来管理输入法和软键盘状态的关键类，它就是源码中一个单例模式应用的典型案例。 12345678910111213141516171819202122232425262728293031public final classs InputMethodManager &#123; /*... 省略代码，保留关键代码 ...*/ static InputMethodManager sInstance; InputMethodManager(IInputMethodManager service, Looper looper) &#123; mService = service; mMainLooper = looper; mH = new H(looper); mIInputContext = new ControlledInputConnectionWrapper(looper, mDummyInputConnection, this); &#125; /** * Retrieve the global InputMethodManager instance, creating it if it * doesn&#x27;t already exist. * @hide */ public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 从代码中，我们可以看到，InputMethodManager中有一个非公开的静态成员变量sInstance,它的构造方法也是非公开的，但是它对外（framwork层）提供了一个public的静态方法getInstance(Context)来对外提供单例对象，当该对象不存在时，就通过进程间通讯创建一个对象。我们试想一下，假如它不是单例的话，在不同的应用中大家都可以自由创建该对象，该对象又极容易造成内存泄漏，创建N个InputMethodManager实例的话，你的Android手机该卡成什么鬼样子？？ 延伸阅读:《Android InputMethodManager 导致的内存泄露及解决方案》 所以说，InputMethodManager做成单例是一个明智的选择，实际上，除了InputMethodManager，直接操作系统资源的许多??Manager都是采用了单例模式来创建，比如AccessibilityManager，InputManager，LayoutInflater，BulutoothManager等。不过他们的单例模式实现多种多样，其中LayoutInflater及许多其他Manager是采用集合缓存的形式的实现，第一次getSystemService(String)获取LayouInflater对象时，系统会通过ServiceFetcher创建一个对象并缓存到系统服务列表中，第二次获取时，直接从列表中得到该对象，并不再二次创建，确保单例。 Android开发中的单例实践大家用过Universal-Image-Loader吗？没用过也没关系，使用UIL加载一张图片非常简单： 1ImageLoader.getInstance().displayImage(imageUrl, imageView); 很眼熟，对不对？其实，这里ImageLoader对象的创建就是采用了单例模式的实现。假如它不是单例实现呢？每次用都初始化一次吗？每次都创建一个新的对象吗？显然这是很浪费资源的一件事，所以ImageLoader是采用了单例模式来创建一个对象，以后用的时候还是复用那个对象，保证了UIL API的易用性，同时也兼顾了系统资源的合理利用。ImageLoader的单例实现代码是 1234567891011121314151617181920212223public class ImageLoader &#123; /* ... 省略代码，保留关键代码 ... */ private volatile static ImageLoader instance; protected ImageLoader() &#123; &#125; /** Returns singleton class instance */ public static ImageLoader getInstance() &#123; if (instance == null) &#123; synchronized (ImageLoader.class) &#123; if (instance == null) &#123; instance = new ImageLoader(); &#125; &#125; &#125; return instance; &#125;&#125; volatile关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全。 总结当你的某个类多次创建很耗资源，或者你的某个类对象你只希望它存在一个实例对象在内存中时，请考虑单例模式。 好了，今天的《设计模式Android篇：单例模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"单例模式","slug":"单例模式","permalink":"http://blog.michaelx.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Singleton","slug":"Singleton","permalink":"http://blog.michaelx.tech/tags/Singleton/"}]},{"title":"Design Patterns in Android：目录纲要","slug":"Design-Patterns-in-Android：目录纲要","date":"2017-01-17T07:14:34.000Z","updated":"2022-12-02T03:10:42.354Z","comments":true,"path":"2017-01/Design-Patterns-in-Android：目录纲要/","link":"","permalink":"http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BA%B2%E8%A6%81/","excerpt":"","text":"前言继《设计模式系列：OOP设计6大原则》之后，博主自此将“间歇性”更新《Design Patterns in Android》（设计模式Android篇），旨在总结自己作为一名Android开发者，在摸索设计模式的过程中爬过的坑，因为很多设计模式的博文，书籍都是针对Java场景的，为了帮助一些Android开发者更贴切的理解和应用设计模式，博文将描述在Android源码中存在的设计模式，以及Android项目如何实践设计模式，将笔者在Android项目实践这些设计模式的心得体会，所得所想以文字的形式展现在读者朋友的眼前，也希望能够和广大的读者有更多的交流，促使自身进步。 间歇性：1、笔者对于23种设计模式也不是全部了解,并没有全部实践过，只能根据自己一些经验来描述一些实践过或者接触过的模式2、笔者中途也会更新其他博文，与读者分享 本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。 什么是设计模式在分享设计模式in Android之前，我们先来看下“设计模式”的定义 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。-维基百科《设计模式 (计算机)》 设计模式这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。并在1994年，埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides“四人帮”（Gang of Four，GoF）著成《设计模式：可复用面向对象软件的基础》为人所熟知并开始广泛流传。 也就是说，设计模式是一种软件编写过程中，解决编程问题的一种可复用的，有规矩可遵循的方案。 快速了解常用23中设计模式，《设计模式教你追MM》 23种设计模式分类根据设计模式的使用场景，大概可分为3类： 创建型处理如何创建实例、对象。 单例模式(Singleton pattern) 原型模式(Prototype pattern) 建造者&#x2F;构造器模式(Builder Pattern) 工厂方法模式(Factory Method pattern) 抽象工厂模式(Abstact Factory) 结构型处理类及对象的复合关系。 适配器模式(Adapter pattern) 桥接模式(Bridge pattern) 组合模式(Composite pattern) 装饰模式(Decorator pattern) 享元模式(Flyweight pattern) 代理模式(Proxy pattern) 行为型 处理类&#x2F;对象之间的转换，通讯。 策略模式(Strategy pattern) 模板方法模式(Template method pattern) 职责链模式(Chain-of-responsibility pattern) 命令模式(Command pattern) 解释器模式(Interpreter pattern) 迭代器模式(Iterator pattern) 仲裁器&#x2F;中介者模式(Mediator pattern) 备忘录模式(Memento pattern) 观察者(模式Observer pattern) 状态模式(State pattern) 参观者&#x2F;访问者模式(Visitor) 结语如上，23种设计模式，各有各的使用场景，应用适当，可以使得代码扩展性大大提高，有利于后期需求变更和功能扩展及代码维护，带有链接的模式表示笔者已有介绍该模式在Android开发中的相关博文。 参考维基百科：《设计模式（计算机）》，《设计模式：可复用面向对象软件的基础》","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"}]},{"title":"设计模式系列：OOP设计6大原则","slug":"设计模式系列：OOP设计6大原则","date":"2017-01-13T02:39:20.000Z","updated":"2022-12-02T03:10:42.356Z","comments":true,"path":"2017-01/设计模式系列：OOP设计6大原则/","link":"","permalink":"http://blog.michaelx.tech/2017-01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%9AOOP%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99/","excerpt":"","text":"前言相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限，你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？ 本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。 Open Close Principle OCP原则（开闭原则）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 wtf???太抽象了！！！在笔者的理解中，OCP是6大原则的最高纲领，所以才如此抽象，晦涩难懂。用面向对象的语言来讲，OCP是一个最抽象的接口，而其余的5大原则只是OCP的子类接口，他们一起定义了OOP世界的开发标准，常用的23中设计模式更是只能算作这6大原则的实现抽象类，咱们开发的代码实践才是真正的具体子类。 1234public interface OCP &#123; void openExtention(); void closeModifiability();&#125; Q:What is OCP？A:OCP是啥咧？它告诉我们，咱们编写的代码应该面向扩展开放，而尽量不要通过修改现有代码来拥抱需求变更。这里，代码可以指的是一个功能模块，类，或者方法。Q:Why do we need to follow this principle？A:我们为什么要遵循OCP原则呢？地球人都知道代码后期需求变更的痛苦，如果不利用扩展来适应变更，那迎来的将是代码被修改的千疮百孔。Q:How do we practice this principle？A:我们如何实践这条原则？能用抽象类的别用具体类，能用接口的别用抽象类。总之一句：尽量面向接口编程。这里之所以说“尽量”是因为凡事都有度，别让你来个hello world你还给整个接口再实现。 talk is cheap，show your the code. 需求：老王开车去东北。 简单，开撸。 老王来了，大家藏好自己媳妇儿。 123456789101112public class Laowang &#123; private Car car; private DongBei dongbei; ... getter() &amp; setter() ... public void drive() &#123; car.goto(dongbei); &#125;&#125; 要车就给你一辆咯 12345678public class Car &#123; public void goto(DongBei dongbei) &#123; System.out.println(“要去东北咯，啦啦啦”); // 模拟开车旅途消耗时间。10s就到东北了，开的可够快的啊！司机之前是开飞机的吗？ Thread.getCurrentThread().sleep(10 * 1000); System.out.println(“目的地东北到了”); &#125;&#125; 东北到了 123public class DongBei &#123; private String address = &quot;东北那旮沓儿&quot;;&#125; 老司机要发车了，赶紧打卡上车。滴，学生卡，咳咳咳，拿错卡了。 12345678public static void main(String[] args) &#123; Car car = new Car(); Laowang wang = new Laowang(); wang.setCar(car); DongBei dongbei = new DongBei(); wang.setDongbei(dongbei); wang.drive();&#125; Perfect，完美！现在需求变了，老王实现了2017年定下的小目标，挣了1个亿，买了架私人飞机，他不想开车去东北了，太low，他要开飞机去东北。 需求2：老王开飞机去东北 简单，给老王加个属性，加几个方法就实现了嘛？代码就不撸了。OK，又是一次完美变化！？需求又变了，老张和老王是穿一条裤裆长大的发小，老张看老王这都开上飞机了，他的车是不是可以借来开一开？ 需求3：老张开车去东北 这，这，这，简单，重新撸一遍老王在需求1的代码就行了，不就改个名的事吗？来来来，需求又变了，老张有急事去东北，老王就把飞机也借给老张用了。 需求4：老张开飞机去东北 这，这，这，这，这，这，简单，把老王在需求2的代码重撸一遍就是了。来来来，需求又变了，老王这回不去东北了，他想开飞机去广东那儿去探望下老丈人，顺便兜兜风。 需求5：老王开飞机去广东 需求6：老张开车去广东 需求7：老王要开飞机去美国 需求8：小王要开车去西藏 需求... 这，这，这，这这这，R&amp;D小哥一口老血喷在屏幕上，卒，享年25岁。 在这里，笔者建议，将人物，交通工具，目的地抽象化，接口化，就可以适应需求的频繁变更了。 上类图客户端代码作如下调整： 1234567891011121314public static void main(String[] args) &#123; // 想用地上开的交通工具出行，好，那就new个车给你开 ITransportation car = new Car(); // 这次是老王要出门 Person wang = new Laowang(); // 老王选择开车出行 wang.setTransportation(car); // 老王目的地是东北 AbsDestination dongbei = new DongBei(); dongbei.setAddressName(&quot;东北&quot;); wang.setDestination(dongbei); // 老司机开着车就出发了 wang.startOff();&#125; 老王的代码如下 123456789public class Laowang extends Person&#123; ... public void startOff() &#123; this.transportation.transport(); System.out.println(&quot;出发咯&quot;); //thread.sleep(); System.out.println(&quot;目的地&quot; + this.destination.getAddressName() +&quot;到了.&quot;); &#125;&#125; 运行结果是： 出发咯 目的地东北到了. 现在，假如要做如上一些需求变更，在需求的变更过程中，客户端的代码变化是不是小多了呢？ 注意：开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层次模块的变化，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，放置变化风险的扩散—秦小波《设计模式之禅》 Single Responsibility Principle SRP原则（职责单一原则）:应该有且只有一个原因引起类的变更。 123public interface SRP extends OCP &#123; void onlyDoOneThing();&#125; 通俗点来讲，一个类，一个方法只应该做一件事情。举2个栗子：1.当一个类A有R1，R2两个职责时，当R1的职责发生变更时，你需要修改类A，当R2发生变更时，你又需要修改类A，这时，已经有2个原因可能会引起类的变化了，类A就已经职责不单一了，就需要职责拆分，比如拆分成类A1，A2：A1类负责R1职责，A2类负责R2职责了。2.再比如有一个方法M，它即负责计算和打印两个职责 123456public void M(int a, int b) &#123; int c = 0; c = a + b; System.out.println(&quot;打印的是 = &quot; + c); &#125; 有一天，你想要修改下计算规则，改为 1c=a+b+1; 此时，你修改了方法M。又一天，你想修改下打印规则，改为 1System.out.println(&quot;打印的是 = &quot; + （c+1）); 你又修改了方法M，此时，超过了2个原因让你去修改它，所以这个方法应该拆分为待返回值得计算calc方法和打印print两个方法。似的每个方法都只做一件事情。 那它是如何体现扩展性的呢？拿一个Android中最常见的ImageLoader的设计来举例子，ImageLoader主要需要实现2个功能，下载图片，缓存图片。假如，我们把所有的功能全部放在一个ImageLoader类中，假设下载要改方式呢？缓存要改策略呢？你通通要改ImageLoader，你如何保证修改某个功能的过程中另一个功能依旧完好，没被污染？拆分职责，使用ImageCache接口及其子类实现进行缓存，和ImageLoader建立关联，职责单一了，你再在每个单一的职责类里面去修改相关代码，这样其他功能代码被污染的概率大大降低。 当然，这里只是随意举的例子，划分单一职责这个度很难把握，每个人都需要根据自身情况和项目情况来进行判断。 Liskov Substitution Principle OCP原则(里氏替换原则)：所有引用基类的地方必须能透明地使用其子类的对象 123public interface LSP extends OCP &#123; void liskovSubstitutionPrinciple();&#125; 通俗点讲：只要父类能出现的地方子类就可以出现，而且替换为子类也不产生任何异常错误，反之则不然。这主要体现在，我们经常使用抽象类&#x2F;基类做为方法参数，具体使用哪个子类作为参数传入进去，由调用者决定。 这条原则包含以下几个方面： 子类必须完全实现父类的方法 子类可以有自己的个性外观（属性）和行为（方法） 覆盖或者实现父类方法时，参数可以被放大。即父类的某个方法参数为HashMap时，子类参数可以是HashMap，也可以是Map或者更大 覆盖或者实现父类的方法时，返回结果可以被缩小。即父类的某个方法返回类型是Map，子类可以是Map，也可以是HashMap或者更小。 Dependence Inversion Principle DIP原则（依赖倒置原则）：高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节而，具体细节应该依赖于抽象 底层模块：不可分割的原子逻辑就是低层模块高层模块：低层模块的组装合成后就是高层模块 抽象：Java中体现为基类，抽象类，接口，而不单指抽象类细节：体现为子类，实现类 通俗点讲，该原则包含以下几点要素： 模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系 接口或者抽象类不依赖于实现类，否则就失去了抽象的意义 实现类依赖于接口或者抽象类 总结起来，一句话：”面向接口编程“。 Interface-Segregation Principle ISP原则（接口隔离原则）:客户端不应该依赖它不需要的接口；类间的依赖应该建立在最小的接口上 通俗点讲：使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。 这里我想举个例子就是Android中的事件处理Listener设计，大家都知道，我们想给button添加点击事件时，可以使用如下代码 1button.setOnClickListener(clickListener); 想给它添加长按事件时，可以使用如下代码 1button.setOnLongClickListener(longClickListener); 还有其他比如OnTouchListener等等等事件接口，它为什么不直接提供一个通用的接口IListener呢？然后回调所有的事件给调用者处理，而要提供这么多独立的接口，这就是遵循了ISP原则的结果，每个接口最小化了，Activity&#x2F;button作为调用者，我可以选择性的去处理我想处理的事件，不关心的事件Listener我就不去处理，依赖。 Low of Demeter LoD法则（迪米特法则）：又称最少知识原则（Least Knowledge Principle， LKP），一个对象应该对其他对象有最少的了解。 通俗点讲：一个类应该对自己需要耦合或者调用的类知道越少越好，被耦合或者调用的类内部和我没有关系，我不需要的东西你就别public了吧。 迪米特法则包含以下几点要素： 只和朋友类交流：只耦合该耦合的类 朋友间也是有距离的：减少不该public的方法，向外提供一个简洁的访问 自家的方法就自己创建：只要该方法不会增加内部的负担，也不会增加类间耦合 感谢和参考秦小波：《设计模式之禅》Mr.simple：《Android 源码设计模式解析与实战》java-my-life:http://www.cnblogs.com/java-my-life/……后话规则只是规则，大家不应该死守规则，应该持辩证的态度去看待这6大原则，才能更好地达到实践应用的目的。感谢以上作者和博客的规范化引导以及诸多博主的博客才渐渐让我懂得实践设计模式与应用架构。笔者将会未来陆续更新《设计模式系列》in Android博客，后续博客中，均参考了以上书籍和博客。欢迎各位朋友评论区点赞拍砖交流。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"6大原则","slug":"6大原则","permalink":"http://blog.michaelx.tech/tags/6%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"name":"OOP","slug":"OOP","permalink":"http://blog.michaelx.tech/tags/OOP/"}]}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/categories/Design-Pattern/"},{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/categories/Android/"},{"name":"hexo","slug":"hexo","permalink":"http://blog.michaelx.tech/categories/hexo/"},{"name":"开源","slug":"开源","permalink":"http://blog.michaelx.tech/categories/%E5%BC%80%E6%BA%90/"},{"name":"科学上网","slug":"科学上网","permalink":"http://blog.michaelx.tech/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.michaelx.tech/tags/Android/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://blog.michaelx.tech/tags/Design-Pattern/"},{"name":"装饰模式","slug":"装饰模式","permalink":"http://blog.michaelx.tech/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"},{"name":"Decorator","slug":"Decorator","permalink":"http://blog.michaelx.tech/tags/Decorator/"},{"name":"责任链模式","slug":"责任链模式","permalink":"http://blog.michaelx.tech/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"},{"name":"Chain-of-responsibility","slug":"Chain-of-responsibility","permalink":"http://blog.michaelx.tech/tags/Chain-of-responsibility/"},{"name":"Bitmap.Config","slug":"Bitmap-Config","permalink":"http://blog.michaelx.tech/tags/Bitmap-Config/"},{"name":"Hexo","slug":"Hexo","permalink":"http://blog.michaelx.tech/tags/Hexo/"},{"name":"travis","slug":"travis","permalink":"http://blog.michaelx.tech/tags/travis/"},{"name":"开源","slug":"开源","permalink":"http://blog.michaelx.tech/tags/%E5%BC%80%E6%BA%90/"},{"name":"LoadingLayout","slug":"LoadingLayout","permalink":"http://blog.michaelx.tech/tags/LoadingLayout/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://blog.michaelx.tech/tags/RecyclerView/"},{"name":"ijkplayer","slug":"ijkplayer","permalink":"http://blog.michaelx.tech/tags/ijkplayer/"},{"name":"AutoInputAuthCode","slug":"AutoInputAuthCode","permalink":"http://blog.michaelx.tech/tags/AutoInputAuthCode/"},{"name":"验证码","slug":"验证码","permalink":"http://blog.michaelx.tech/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"科学上网","slug":"科学上网","permalink":"http://blog.michaelx.tech/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://blog.michaelx.tech/tags/Shadowsocks/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.michaelx.tech/tags/Ubuntu/"},{"name":"AOSP","slug":"AOSP","permalink":"http://blog.michaelx.tech/tags/AOSP/"},{"name":"Nexus","slug":"Nexus","permalink":"http://blog.michaelx.tech/tags/Nexus/"},{"name":"Pixel","slug":"Pixel","permalink":"http://blog.michaelx.tech/tags/Pixel/"},{"name":"BLE","slug":"BLE","permalink":"http://blog.michaelx.tech/tags/BLE/"},{"name":"智能硬件","slug":"智能硬件","permalink":"http://blog.michaelx.tech/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6/"},{"name":"模板方法模式","slug":"模板方法模式","permalink":"http://blog.michaelx.tech/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"name":"Template Method","slug":"Template-Method","permalink":"http://blog.michaelx.tech/tags/Template-Method/"},{"name":"策略模式","slug":"策略模式","permalink":"http://blog.michaelx.tech/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"Strategy","slug":"Strategy","permalink":"http://blog.michaelx.tech/tags/Strategy/"},{"name":"单例模式","slug":"单例模式","permalink":"http://blog.michaelx.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Singleton","slug":"Singleton","permalink":"http://blog.michaelx.tech/tags/Singleton/"},{"name":"6大原则","slug":"6大原则","permalink":"http://blog.michaelx.tech/tags/6%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"name":"OOP","slug":"OOP","permalink":"http://blog.michaelx.tech/tags/OOP/"}]}